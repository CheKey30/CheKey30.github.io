<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="The place to share tech and life"><meta name="keywords" content=""><meta name="author" content="Shuchen"><meta name="copyright" content="Shuchen"><title>Do not panic， keep coding | Shuchen's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.1.0'
} </script><meta name="generator" content="Hexo 5.1.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Shuchen</div><div class="author-info__description text-center">The place to share tech and life</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">20</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Shuchen's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Shuchen's blog</div><div id="site-sub-title">Do not panic， keep coding</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/30/dubbo-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02/">Dubbo 入门笔记2</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-30</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/dubbo/">dubbo</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍dubbo的核心概念，架构和相关组件的搭建</p></div><a class="more" href="/2020/05/30/dubbo-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/JDK-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/">JDK 源码学习笔记 1</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JDK/">JDK</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从本文开始对JDK源码进行学习，内容包含Java中各种常见数据结构的底层实现原理和其他重要的Java函数的底层实现。本文包括JDK源码阅读环境搭建</p></div><a class="more" href="/2020/03/25/JDK-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/19/dubbo-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/">Dubbo 入门笔记1</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-19</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/dubbo/">dubbo</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录应用架构的发展，RPC的思想。</p>
<!-----------------------more------------------------------>

<h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><p>分布式系统是若干独立计算机的集合，这些计算机对用户来说是单个的相关系统。</p>
<p>直白解释：多台计算机负责不同的功能，相互交互，但对用户来说和用一台计算机没有区别。</p>
<p>单一服务器无法完成如此复杂和如此大量的需求（比如淘宝），因此将不同的功能拆分成不同的功能模块，分别部署在不同的服务器上。</p>
<h1 id="应用架构的发展"><a href="#应用架构的发展" class="headerlink" title="应用架构的发展"></a>应用架构的发展</h1>

<h2 id="单一架构应用"><a href="#单一架构应用" class="headerlink" title="单一架构应用"></a>单一架构应用</h2><p>所有的功能模块全部写在一个程序之中，打包成一个包，部署在一个服务器上。当流量不大，功能简单时方便好用。如果流量增大，则服务器无法承受。当功能复杂时，即使部署多台服务器，每一台也无法承受。</p>
<p>难以扩展，难以协同和维护（任何小的改动都需要在所有服务器上更改）</p>
<h2 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h2><p>将程序拆分成几块<strong>互不相关</strong>的独立应用，分别部署，并且将压力大的部分多部署几台。</p>
<p>无法做到界面和业务逻辑的分离，每次页面的小改动都需要重新部署</p>
<p>应用不可能完全独立，大量的应用之间需要交互。</p>
<h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><p>将应用的核心业务抽取出来，前后端分离。有的服务器专门部署各个界面，其他服务器分别部署应用的不同核心业务逻辑，之间进行交互。</p>
<p>之前同一业务在同一服务器上，进行的是进程内通讯，现在的交互是不同服务器间的，称为远程过程调用remote procedure call（RPC）。</p>
<p>分布式架构的难点在于如何进行RPC和如何拆分业务以减少重复。</p>
<p>无法进行动态调控，由于部署各个业务的服务器个数是一定的，会造成压力大的业务服务器不够，压力小的业务服务器闲置浪费</p>
<h2 id="流动计算架构-SOA（Service-Oriented-Architecture）"><a href="#流动计算架构-SOA（Service-Oriented-Architecture）" class="headerlink" title="流动计算架构 SOA（Service-Oriented Architecture）"></a>流动计算架构 SOA（Service-Oriented Architecture）</h2><p>引入调度中心，负责维护服务间的复杂关系，实时管理服务集群，给访问量大的业务多分配服务器。并且平衡跑相同业务的服务器上的请求个数。</p>
<h1 id="RPC（remote-procedure-call）"><a href="#RPC（remote-procedure-call）" class="headerlink" title="RPC（remote procedure call）"></a>RPC（remote procedure call）</h1>

<p>一种进程间的通信方式，是思想而不是规范。（类比JVM是一种思想，各种JVM的实现就是规范）</p>
<p>A服务器要调用B服务器上的方法，A上的stub通过网络和B建立连接并且传出相关的参数，之后B上的stub接受参数，执行相应的方法，将操作的结果传回给A。通过stub的帮助，表面上调用远程方法和调用本地方法没有差别。</p>
<p>对于实现这种RPC思想的RPC框架，<strong>通信效率</strong>和<strong>序列化反序列化效率</strong>是两个评判标准。</p>
<p>常见的RPC框架：dubbo， gRPC，Thrift，HSF</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/20/MySQL%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/">MySQL笔记之三事务的隔离级别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-20</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MySQL/">MySQL</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录MySQL事务隔离级别的相关知识，包括四种隔离级别，默认级别，不同存储引擎采用的锁。</p>
<!-------------------more---------------->

<h1 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h1><p>事务是由一组sql语句组成的逻辑处理单元，具有ACID的属性</p>
<ul>
<li>Atomicity（原子性）：一個事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BB%9A_(%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86)">回滚</a>（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7">约束</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93)">触发器</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A">级联回滚</a>等。</li>
<li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><p>事务a和事务b之间有一定的隔离性</p>
<p>隔离性有隔离级别（4个）：</p>
<ol>
<li>读未提交 read uncommitted</li>
<li>读已提交 read committed</li>
<li>可重复读 repeatable</li>
<li>串行化 serializable</li>
</ol>
<p>隔离级别递增</p>
<p>read uncommitted 最低级别的隔离，a事务未提交的数据事务b可以读取到（脏读），一般理论存在</p>
<p>数据库默认的隔离级别一般高于此。读取的是内存里的数据</p>
<p>read committed 事务a提交的数据事务b才能读取到，可避免脏读，但是导致不可重复读取（事务b每次读取事务a的数据都不同，因为a提交了新的数据）不符合隔离性，读取的是硬盘里的数据。oracle默认的隔离级别。</p>
<p>repeatable：可重复读取，事务a提交了，事务b仍然读取不到。事务b可重复读取数据（每次拿到的都是事务a提交前的数据），b读取的是内存里自己存的a的数据。<strong>MySQL默认的隔离级别</strong>。会导致幻象读（事务结束后再次读取会有很大差异）</p>
<p>MVCC（多版本并发控制）机制：可重复读的隔离级别下使用了MVCC机制，select不会更新版本号，是快照读（自己内存里的数据），但所有更新操作会更新版本号，是当前读。</p>
<p>serializable：事务a在操作表中数据的时候，事务b只能等待。很少使用，吞吐量太低。</p>
<p>解决幻读问题：java代码同步并发、mysql间隙锁：通过where条件给表中的多条数据添加行锁，即使这条数据还不存在，也会加锁，这样操作，则其他session不能更新这几条数据，当前session读取出的数据一定是真实的。</p>
<h1 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h1><p>乐观锁：用版本对比实现数据更新，如果一个线程更新一个数据时发现此时的版本和自己查询到的版本不同（即该数据已经被其他线程更新过了）则更新失败。线程更新数据成功会增加数据的版本。</p>
<p>悲观锁：只允许一个线程访问数据。</p>
<p>表锁（对一张表加锁，分读和写锁，偏读）：</p>
<p><strong>MYISAM采用表锁，不支持事务</strong></p>
<p>加读锁：当前session和其他session都可以读这张表，当前session中插入或更新表会报错，其他session更新数据会被阻塞。（即不让任何session在当前session读取完表之前更改）</p>
<p>加写锁：当前session可进行任何操作，其他session全部阻塞。（即当前session更新完毕前不让任何其他session访问该表）</p>
<p>MYISAM 会在执行select时给对应表加读锁，在更改前加写锁。</p>
<p>行锁（对一行数据加锁，偏写）：</p>
<p><strong>InnoDB采用行锁，支持事务。</strong></p>
<p>在当前session更新一行数据，如果没有提交，则此时其他session不能更新这条数据，会阻塞。只有这个session的事务commit之后，才能更新。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/20/MySQL%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E5%92%8C%E4%BC%98%E5%8C%96/">MySQL笔记之二索引建立和优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-20</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MySQL/">MySQL</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文讨论MySQL中索引的建立方式和优化原则</p>
<!----------------------more------------------------------------->

<h1 id="索引的建立"><a href="#索引的建立" class="headerlink" title="索引的建立"></a>索引的建立</h1><p>上一篇文章中讲述了MySQL的存储结构为B+树，因此，建立索引就是建立B+树的过程。对一张MySQL的表格而言，一般存在一个主键，则以主键为关键字建立B+树就是最基本的一种。除此以外，还可以针对非主键字段建立B+树来加快搜索。还可以针对多个字段建立索引，称为联合索引。</p>
<h2 id="非主键索引的底层数据结构"><a href="#非主键索引的底层数据结构" class="headerlink" title="非主键索引的底层数据结构"></a>非主键索引的底层数据结构</h2><p>在nnoDB中，对于一个非主键索引，同样建立b+树，</p>
<p>不同点是，<strong>叶子节点的元素不是整个数据，而是主键的值</strong>。因此通过非主键索引来查询会进行两次，先找到主键值，再去主键索引里找</p>
<p>优点：节省空间，保证一致性（如果每个索引都保存全部值，则按不同索引更新时就会出现不同）</p>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>按照多个字段建立索引，此时顺序尤为重要。比如有三个字段来做索引，emp_no，title，from_date，则搜索时会先按第一个字段找，相同再按第二个，还相同按第三个。因此，联合索引只能按顺序使用，不能跳用。（如果不用第一个，就不能用第二个）</p>


<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2>

<p>分析：</p>
<p>总共建立了三个索引，是联合索引，分别为emp_no，title，from_date</p>
<ol>
<li>会用到索引的三个字段</li>
<li>不会用索引(没用第一个字段，直接用了第二个字段)</li>
<li>会用索引</li>
<li>会用一个</li>
<li>会用</li>
</ol>
<h1 id="索引优化原则"><a href="#索引优化原则" class="headerlink" title="索引优化原则"></a>索引优化原则</h1><h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><p>由于联合索引会先按第一个字段比较，然后第二，然后第三。因此，如果查询语句的查询条件里没有第一个字段，只有二三，则不会运用联合索引。会遍历表逐行判断。</p>
<p>同理，只有1,3字段也不行。想用联合索引，查询语句的判断条件中必须包含从第一个字段开始的连续字段。</p>
<p>这就是最左前缀法则。即联合索引用了三个字段abc，则查询条件也要是a=，b=，c=或者a=，b=。即<strong>查询条件顺序必须和联合索引顺序相同</strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/18/MySQL%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">MySQL笔记之一 存储结构，存储引擎</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-18</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MySQL/">MySQL</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录MySQL底层的存储数据结构和存储引擎。</p>
<!--------------more---------------->

<h1 id="MySQL存储结构"><a href="#MySQL存储结构" class="headerlink" title="MySQL存储结构"></a>MySQL存储结构</h1><p>从需求的角度出发来考虑可以用的数据结构。对于数据库来说，最重要的功能就是要快速找到需要的数据。因此，线性的存储结构比如数组，链表等都不做考虑，用遍历的方式找到数据太过缓慢。可用的数据结构有哈希表，搜索二叉树，红黑树，b树，b+树等。下面逐一分析优劣来理解为什么MySQL选择了b+树作为存储结构。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表的特点是能够在O(1)的时间复杂度内找到所需的元素。其原理是将键值对的键利用哈希函数转换，变成等长的形式，之后存在相应的内存地址上，之后查询的时候就对键做同样操作，然后去内存上找到对应位置即可。</p>
<p>优点：查找快速</p>
<p>缺点：</p>
<ol>
<li>数据量过大时哈希冲突会很多，此时每个地址下存入的都是一个红黑树，查找也会变慢。</li>
<li>只能做精确查找，无法完成范围查找</li>
</ol>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>搜索二叉树是一种特殊的二叉树，对每一个节点，若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</p>
<p>优点：可以做范围查找，查询速度为O(logn)</p>
<p>缺点：</p>
<ol>
<li>如果维护的字段是递增的，则生成的二叉树很不平衡（只有右子），此时查找仍是O(n)</li>
<li>大量数据会造成深度过深，此时搜索仍旧很慢</li>
</ol>
<p>对于第一点的优化可以使用红黑树，但仍旧无法解决第二个缺点</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树是一种平衡树，即每个叶结点的深度相同，以此来防止非平衡树带来的查询复杂度不同的问题，同时每个节点可以存储多个数据，解决深度过深的问题。具体定义以下概念：</p>
<ol>
<li>度：指节点存储的数据个数</li>
<li>阶：指节点最多能存储的数据个数</li>
</ol>
<p>对于一颗m阶的B树，其满足：</p>
<ol>
<li>每个结点最多有m-1个关键字。</li>
<li>根结点最少可以只有1个关键字。</li>
<li>非根结点至少有Math.ceil(m/2)-1个关键字。</li>
<li>每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li>
<li>所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。</li>
</ol>


<p>具体的插入删除操作参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/nullzx/p/8729425.html">https://www.cnblogs.com/nullzx/p/8729425.html</a></p>
<p>具体的动画演示：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p>
<p>优点：解决了大量数据的存储和查询问题</p>
<p>缺点：每个节点能够存储的元素有限。MySQL需要将节点读入内存来进行查找工作，由于每个节点包含关键字（key）和所有值（value），因此内存限制了一次无法读入很多节点，降低搜索效率。</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>和B树类似，有两点不同</p>
<ol>
<li>所有的值都存在叶子节点，非叶子节点只存储关键字</li>
<li>叶子节点之间用指针连接，方便范围查找</li>
</ol>
<p>m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。</p>
<p>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都<strong>小于</strong>它，右子树中的key都<strong>大于等于</strong>它。叶子结点中的记录也按照key的大小排列。</p>


<p>动画演示：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p>
<p>优点：满足大量数据快速查询，由于非叶子节点只存索引，可以一次尽可能多的加载索引进入内存，加快查找。同时叶子节点之间的指针加快范围查找。</p>
<p>mysql底层bigint类的索引占8字节，指针占6字节，默认每个索引字段的大小为16kb（每个节点就是一个索引字段），由此得出，每个索引字段可以存大概1000个元素（索引）</p>
<h1 id="MySQL-的搜素引擎"><a href="#MySQL-的搜素引擎" class="headerlink" title="MySQL 的搜素引擎"></a>MySQL 的搜素引擎</h1><p>先明确一点，MySQL的存储引擎是用来<strong>形容表的，不是数据库</strong>。它决定了一张表是如何存储在硬盘上的。</p>
<p>常见的存储引擎有MYISAM和InnoDB。</p>
<h2 id="MYISAM"><a href="#MYISAM" class="headerlink" title="MYISAM"></a>MYISAM</h2><p>对于每张表，MYISAM有三个文件：.MYD , .MYI, .frm</p>
<p>frm 是表结构定义的文件</p>
<p>MYD是数据的存储</p>
<p>MYI是索引的存储，主键是自带索引的。</p>


<p>拿到需要的索引，进入MYI文件通过b+树定位，找到对应的指针（myiSAM），在用这个指针去MYD文件里定位到对应的位置。</p>
<p>是非聚集索引（数据和索引分开存储）</p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>INNODB的存储只有两个文件.frm和.ibd</p>
<p>其中ibd保存索引和数据，不用指针来定位，直接把索引和数据存在一起</p>


<p>表数据本身就是按照b+树结构来存储的</p>
<p><strong>聚集索引：叶子节点包含了完整的数据记录</strong></p>
<p>innoDB必须要建立主键来组织b+树，并且推荐用自增整形来做主键，因为1.节约存储空间2.搜素过程需要比大小</p>
<p>3.自增是因为b+树必须维护元素有序，当插入的元素不是结尾元素时，b+树已经生成的结构可能需要重构（之前的一个索引字段已经满了，又要插入一个，则这个字段必须分裂）</p>
<p>叶子节点之间的指针（双向指针）：用来进行范围查找，找到边界的节点，之后利用这个指针找到左右需要的范围</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/08/31/Manacher/">Manacher</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-31</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/algorithm/">algorithm</a></span><div class="content"><h1 id="Manacher-求最长回文子串"><a href="#Manacher-求最长回文子串" class="headerlink" title="Manacher: 求最长回文子串"></a>Manacher: 求最长回文子串</h1><p>该算法用于求最长回文字串，可在O(n)内求出一个字符串的最长回文字串，暴力做法需要O(n^2)的时间。主要运用动态规划的思想，之前求过的信息（以某个位置为对称中心的最长回文半径）在之后可以被反复运用，无需再求一次。</p>
<!-----------------------------------------more----------------------------->

<h1 id="具体做法："><a href="#具体做法：" class="headerlink" title="具体做法："></a>具体做法：</h1><ol>
<li>先将字符串预处理，取消奇偶字符串的差异，具体做法是在当前字符串的每个字符间隔内插入一个不会出现在字符串中的符号，比如#。</li>
<li>构造一个和字符串等长的数组dp，dp[i]表示以i为对称轴的最长回文的回文半径。最终结果就是dp中最大值-1。</li>
<li>同时维护一个maxright和idx，分别表示当前探查到的形成回文的最右边的位置maxright和以该位置结尾的回文的中心idx。</li>
<li>遍历数组，当到达i位置时，i位置肯定在idx右边。有两种情况 (1) i位置超过了maxright，则当前保存的已知信息已经没用了，直接以i为中心左右比对去找到最大的回文，之后更新maxright和idx。(2) i没有超过maxright，则找到和i关于idx对称的位置j，j=2*idx-i。可以直接读取出dp[j]。又分两种情况，(a) j做对称轴的最长回文半径大于i到maxright的距离，此时只能确定i到maxright的部分是回文的，因此从maxright+1位置开始，以i为中心左右比对。（b）j做对称轴的最长回文半径小于等于i到maxright的距离，此时i至少也用于同样的半径，因此从这个半径的下一位开始探查。结束后更新maxright和idx。</li>
<li>遍历结束，找到dp中的最大值，由于字符串经过了处理，这里的最大半径-1刚好就是原串的最长回文。</li>
</ol>
<h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><p>python:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">s</span>):</span></span><br><span class="line">       s = <span class="string">&quot;#&quot;</span>+<span class="string">&quot;#&quot;</span>.join(s)+<span class="string">&quot;#&quot;</span></span><br><span class="line">       dp = [<span class="number">0</span>]*len(s)</span><br><span class="line">       maxRight = <span class="number">0</span></span><br><span class="line">       idx =<span class="number">0</span></span><br><span class="line">       res = <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">           <span class="keyword">if</span> i&lt;maxRight:</span><br><span class="line">               dp[i] = min(dp[<span class="number">2</span>*idx-i],maxRight-i)</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               dp[i]=<span class="number">1</span></span><br><span class="line">           <span class="keyword">while</span> i-dp[i]&gt;=<span class="number">0</span> <span class="keyword">and</span> i+dp[i]&lt;len(s) <span class="keyword">and</span> s[i-dp[i]]==s[i+dp[i]]:</span><br><span class="line">               dp[i]+=<span class="number">1</span></span><br><span class="line">           <span class="keyword">if</span> dp[i]+i<span class="number">-1</span>&gt;maxRight:</span><br><span class="line">               maxRight=dp[i]+i<span class="number">-1</span></span><br><span class="line">               idx = i</span><br><span class="line">           res = max(res,dp[i])</span><br><span class="line">       <span class="keyword">return</span> res<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] tmp = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[tmp.length*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> j =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tmp.length;i++)&#123;</span><br><span class="line">        arr[j++]=tmp[i];</span><br><span class="line">        arr[j++]=<span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] dp = <span class="keyword">new</span> <span class="keyword">char</span>[arr.length];</span><br><span class="line">    <span class="keyword">int</span> maxright =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;maxright)&#123;</span><br><span class="line">            dp[i] = min(dp[<span class="number">2</span>*idx-i],maxright-i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i-dp[i]&gt;=<span class="number">0</span> &amp;&amp; i+dp[i]&lt;arr.length &amp;&amp; arr[i-dp[i]] == arr[i+dp[i]])&#123;</span><br><span class="line">            dp[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]+i&gt;maxright)&#123;</span><br><span class="line">            maxright = dp[i]+i-<span class="number">1</span>;</span><br><span class="line">            idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,dp[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h1><ol>
<li>有时候要求求出具体的最长子回文是什么，此时结果不再记录数子，而是记录最长的对称轴和半径idx和r，则在变换字符串中idx-r+1到idx+r-1之间就是最长回文字串，取到，去标记#即可。</li>
<li>有时候不需要连续，只要是子集（子序列）即可，则转化为一道动态规划的问题，不用这个算法解。</li>
</ol>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003914228#articleHeader3">https://segmentfault.com/a/1190000003914228#articleHeader3</a></li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/08/31/Tree/">Tree</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-31</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/algorithm/">algorithm</a></span><div class="content"><h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><strong>二叉树</strong>：二叉树是有限个结点的集合，这个集合或者是空集，或者是由一个根结点和两株互不相交的二叉树组成，其中一株叫根的做左子树，另一棵叫做根的右子树。</p>
<p><strong>二叉树的性质</strong>：</p>
<ul>
<li>性质1：在二叉树中第 i 层的结点数最多为2^(i-1)（i ≥ 1）</li>
<li>性质2：高度为k的二叉树其结点总数最多为2^k－1（ k ≥ 1）</li>
<li>性质3：对任意的非空二叉树 T ，如果叶结点的个数为 n0，而其度为 2 的结点数为 n2，则：<code>n0 = n2 + 1</code></li>
</ul>
<p><strong>满二叉树</strong>：深度为k且有2^k －1个结点的二叉树称为满二叉树</p>
<p><strong>完全二叉树</strong>：深度为 k 的，有n个结点的二叉树，当且仅当其每个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应，称之为完全二叉树。（除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点）</p>
<ul>
<li>性质4：具有 n 个结点的完全二叉树的深度为 log2n + 1</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>仅有前序和后序遍历，不能确定一个二叉树，必须有中序遍历的结果</li>
</ul>
<!-----------------------------more---------------------------------------->

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（如果有的话） 的元素，则称此完全二叉树为最大堆。</p>
<p>同样，如果一棵完全二叉树的任意一个非终端结点的元素都不大于其左儿子结点和右儿子结点（如果 有的话）的元素，则称此完全二叉树为最小堆。</p>
<p><strong>最大堆的根结点中的元素在整个堆中是最大的；</strong></p>
<p><strong>最小堆的根结点中的元素在整个堆中是最小的。</strong></p>
<h2 id="哈弗曼树"><a href="#哈弗曼树" class="headerlink" title="哈弗曼树"></a>哈弗曼树</h2><ul>
<li><p>定义：给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。</p>
</li>
<li><p>构造：</p>
<p>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：</p>
<ol>
<li>将w1、w2、…，wn看成是有 n 棵树的森林(每棵树仅有一个结点)；</li>
<li>在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；</li>
<li>从森林中删除选取的两棵树，并将新树加入森林；</li>
<li>重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</li>
</ol>
</li>
</ul>
<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。</p>
<p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ol>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
<li>没有键值相等的节点</li>
</ol>
<p>二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找）</p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>平衡二叉树（balanced binary tree）,又称 AVL 树。它或者是一棵空树,或者是具有如下性质的二叉树：</p>
<ol>
<li>它的左子树和右子树都是平衡二叉树，</li>
<li>左子树和右子树的深度之差的绝对值不超过1。</li>
</ol>
<p>平衡二叉树是对二叉搜索树(又称为二叉排序树)的一种改进。二叉搜索树有一个缺点就是，树的结构是无法预料的，随意性很大，它只与节点的值和插入的顺序有关系，往往得到的是一个不平衡的二叉树。在最坏的情况下，可能得到的是一个单支二叉树，其高度和节点数相同，相当于一个单链表，对其正常的时间复杂度有O(log(n))变成了O(n)，从而丧失了二叉排序树的一些应该有的优点。</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p><strong>B-树</strong>：B-树是一种非二叉的查找树， 除了要满足查找树的特性，还要满足以下结构特性：</p>
<p>一棵 m 阶的B-树：</p>
<ol>
<li>树的根或者是一片叶子(一个节点的树),或者其儿子数在 2 和 m 之间。</li>
<li>除根外，所有的非叶子结点的孩子数在 m/2 和 m 之间。</li>
<li>所有的叶子结点都在相同的深度。</li>
</ol>
<p>B-树的平均深度为logm/2(N)。执行查找的平均时间为O(logm)；</p>
<h2 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h2><p>Trie 树，又称前缀树，字典树， 是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>Trie 树查询和插入时间复杂度都是 O(n)，是一种以空间换时间的方法。当节点树较多的时候，Trie 树占用的内存会很大。</p>
<p>Trie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
<h1 id="解决树问题的一般递归思路"><a href="#解决树问题的一般递归思路" class="headerlink" title="解决树问题的一般递归思路"></a>解决树问题的一般递归思路</h1><p>给定一棵树（此处以二叉树为例），要求求出某种满足条件的结果（如最大路径和）或者判断某结果是否成立（如判断是否为平衡二叉树）。<br>一般思路是：当前节点做根节点，要得到结果，<br>    1. 需要自己的左子树给自己什么。<br>    2. 需要自己的右子树给自己什么。<br>    3. 需要自己进行什么操作。<br>    4. 将自己需要的东西同理的求出来返回给自己的上级（自己的根节点）。<br>    5. 考虑边界条件，一般是节点为空时如何处理，加在函数开头做判断。<br>调用这个递归函数，把根节点作为输入，得到的结果就是最终的结果。</p>
<h2 id="判断二叉树是否为平衡二叉树"><a href="#判断二叉树是否为平衡二叉树" class="headerlink" title="判断二叉树是否为平衡二叉树"></a>判断二叉树是否为平衡二叉树</h2><p>lc110</p>
<p>思路：<br>每个节点需要直到自己左子树的深度，右子树的深度。如果这两个深度相差超过1，则不是平衡二叉树，如果没超过，则算出自己的深度（左右子深度大的+1），返回给自己的父节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsBalanceTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> balance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalance</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = helper(node.left);</span><br><span class="line">        <span class="keyword">int</span> right = helper(node.right);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(left-right)&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找到二叉树中的最大路径和"><a href="#找到二叉树中的最大路径和" class="headerlink" title="找到二叉树中的最大路径和"></a>找到二叉树中的最大路径和</h2><p>lc 124</p>
<p>思路：<br>对于一个节点，需要左右子树给自己以左右子为一端的最大路径和。之后更新最大路径和，最大路径和有可能是当前节点值加上左右子返回的值（如果这两个值中有负的则没有加的必要），或者之前的值。之后求出以自己为开头的最大路径和返回上一级。考虑节点为空的情况，返回0即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPathSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=Integer.MIN_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>,helper(root.left));</span><br><span class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>,helper(root.right));</span><br><span class="line">        <span class="keyword">this</span>.res = Math.max(<span class="keyword">this</span>.res,root.val+left+right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p>lc226</p>
<p>思路：</p>
<p>对于每个节点，交换自己的左右子树，之后把自己返回给自己的父节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = node;</span><br><span class="line">        helper(root.left);</span><br><span class="line">        helper(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="特殊树的性质运用"><a href="#特殊树的性质运用" class="headerlink" title="特殊树的性质运用"></a>特殊树的性质运用</h1><h2 id="搜索二叉树"><a href="#搜索二叉树" class="headerlink" title="搜索二叉树"></a>搜索二叉树</h2><p>对于搜素二叉树，中序遍历的结果会是一个有序递增序列，利用这一点通过中序遍历来找到答案，不需要一般树的思考过程。</p>
<h3 id="找到搜索二叉树中排错的两个点并更正"><a href="#找到搜索二叉树中排错的两个点并更正" class="headerlink" title="找到搜索二叉树中排错的两个点并更正"></a>找到搜索二叉树中排错的两个点并更正</h3><p>lc 99</p>
<p>思路：中序遍历二叉树，如果是正确的，后边的值一定比前边的大，反之证明前面这个值放错地方了，接着遍历，因为只有一处错误，后边一定有且仅有一个比这个错误值小的，找到后交换这两个值即可。（用三个指针分别存两个错误值和当前值的前一个）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecoveryBST</span> </span>&#123;</span><br><span class="line">    TreeNode first = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode second = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode prve = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">recovery</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">this</span>.first.val^=<span class="keyword">this</span>.second.val;</span><br><span class="line">        <span class="keyword">this</span>.second.val^=<span class="keyword">this</span>.first.val;</span><br><span class="line">        <span class="keyword">this</span>.first.val^=<span class="keyword">this</span>.second.val;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.left);</span><br><span class="line">        <span class="keyword">if</span>(prve != <span class="keyword">null</span> &amp;&amp; prve.val&gt;root.val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first ==<span class="keyword">null</span>)&#123;</span><br><span class="line">                first = prve;</span><br><span class="line">            &#125;</span><br><span class="line">            second = root;</span><br><span class="line">        &#125;</span><br><span class="line">        prve = root;</span><br><span class="line">        helper(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a target="_blank" rel="noopener" href="https://hit-alibaba.github.io/interview/basic/algo/Tree.html">https://hit-alibaba.github.io/interview/basic/algo/Tree.html</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/08/31/bit-manipulation/">Bit Manipulation</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-31</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/algorithm/">algorithm</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>基本思路：将给定的数字都转化为二进制，然后进行相应的操作。</p>
<!----------------------more---------------------------->

<h1 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h1><p>符号&lt;&lt;</p>
<p>操作：将数字转换成二进制，然后左移x位，空缺补零。</p>
<p>效果：乘2^x</p>
<p>例子：</p>
<p>7&lt;&lt;1 =14, 7&lt;&lt;2=28…</p>
<p>7的二进制是111，左移后变成1110是14。</p>
<h1 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h1><p>符号：&gt;&gt;</p>
<p>操作：将数字转化成二进制，然后右移x位</p>
<p>效果：除2^x</p>
<p>例子：</p>
<p>7&gt;&gt;1=3, 7&gt;&gt;2=1</p>
<p>7的二进制是111，右移变成11。</p>
<h1 id="与操作"><a href="#与操作" class="headerlink" title="与操作"></a>与操作</h1><p>符号：&amp;</p>
<p>操作：将两数字a，b转换成二进制，如果位数不同短的前面补零，之后逐位算与，得到结果。</p>
<p><strong>常用：用a&amp;1判断a的奇偶。</strong></p>
<p>例子：</p>
<p>7&amp;3=3</p>
<p>111</p>
<p>&amp;</p>
<p>011</p>
<p>=011=3</p>
<h1 id="或操作"><a href="#或操作" class="headerlink" title="或操作"></a>或操作</h1><p>符号|</p>
<p>符号：&amp;</p>
<p>操作：将两数字a，b转换成二进制，如果位数不同短的前面补零，之后逐位算或，得到结果。</p>
<p>例子：</p>
<p>7&amp;3=7</p>
<p>111</p>
<p>|</p>
<p>011</p>
<p>=</p>
<p>111</p>
<h1 id="抑或操作"><a href="#抑或操作" class="headerlink" title="抑或操作"></a>抑或操作</h1><p>符号：^</p>
<p>操作：将两数字转换为二进制，长度不等短的前面补零，二者逐位比较，相同为0，不同为1</p>
<p>例子：</p>
<p>7^3=4</p>
<p>111</p>
<p>^</p>
<p>011</p>
<p>=</p>
<p>100=4</p>
<p>应用：交换两数字a，b： </p>
<p>a^=b </p>
<p>b^=a </p>
<p>a^=b</p>
<p>三部操作后a，b互换</p>
<p>比如：</p>
<p>a=101 b=11101。操作一后 a=11000 操作二后 b=101 操作三后 a = 11101。 </p>
<h1 id="非操作"><a href="#非操作" class="headerlink" title="非操作"></a>非操作</h1><p>符号:~</p>
<p>操作：将数子转换为二进制，每位取反（此时前面的0也作数，比如Java中32位表示一个整数）</p>
<p>例子：</p>
<p>～7=-8</p>
<p>~00000000000000000000000000000111</p>
<p>=</p>
<p>11111111111111111111111111111000</p>
<p>=-8</p>
<h1 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h1><p>符号：&gt;&gt;&gt;</p>
<p>操作：无视整数的正负，将其右移一位。</p>
<h1 id="Java-正负数的表示"><a href="#Java-正负数的表示" class="headerlink" title="Java 正负数的表示"></a>Java 正负数的表示</h1><p>Java中用32为表示一个整数，其中最高位表示的是整数的符号，0为正1为负。因此有以下几点注意：</p>
<ol>
<li><p>得到一个数的相反数就将其取反+1。比如：7=00000000000000000000000000000111，,7=11111111111111111111111111111001</p>
</li>
<li><p>对于右移操作（&gt;&gt;），考虑原来数字的正负，因此移动完毕后在前面用0或1补位（正数补0，负数补1）。而对于无符号右移操作（&gt;&gt;&gt;），不考虑符号，移动完毕后都补0。比如：</p>
<p>7&gt;&gt;1=3,  -7&gt;&gt;1=-3,  7&gt;&gt;&gt;1=3,   -7&gt;&gt;&gt;1=2147483644。（对正数来说都一样）。</p>
</li>
<li><p>左移操作没有无符号一说，都是在末尾补0。</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/08/03/Stack-and-Queue/">Stack and Queue</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-03</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/algorithm/">algorithm</a></span><div class="content"><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>Stack，栈，一种数据结构，拥有“先进后出”的特性，简单来说就是先进入栈的元素会后出栈。类似叠放的一摞盘子，放在底部的盘子是先放进来的，但要想拿到就必须先把后放入的在它上面的盘子都拿出来。</p>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue，队列，另一种数据结构，拥有“先进先出”的特性，就是先进入队列的元素先出队列。类似排队，先排入队伍中的先被服务，出队列。</p>
<!-----------------more---------------->
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="Stack-1"><a href="#Stack-1" class="headerlink" title="Stack"></a>Stack</h2><p>list 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Stack(object):</span><br><span class="line">    def __init__(object):</span><br><span class="line">        self.stack &#x3D; []</span><br><span class="line"></span><br><span class="line">    def push(self, value):</span><br><span class="line">        self.stack.append(value)</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        if self.stack:</span><br><span class="line">            self.stack.pop()</span><br><span class="line">        else:</span><br><span class="line">            raise LookupError(&#39;stack is empty!&#39;)</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return bool(self.stack)</span><br><span class="line"></span><br><span class="line">    def top(self):</span><br><span class="line">        return self.stack[-1]</span><br></pre></td></tr></table></figure>
<p>链表实现：<br>用head存储栈的头尾，使操作都为O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class Head(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.left &#x3D; None   # left存储栈底</span><br><span class="line">        self.right &#x3D; None  # right存储栈顶</span><br><span class="line"></span><br><span class="line">class Node(object):</span><br><span class="line">    def __init__(self, value):</span><br><span class="line">        self.value &#x3D; value</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Stack(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        #初始化节点</span><br><span class="line">        self.head &#x3D; Head()</span><br><span class="line"></span><br><span class="line">    def push(self, value):</span><br><span class="line">        #插入一个元素</span><br><span class="line">        newnode &#x3D; Node(value)</span><br><span class="line">        p &#x3D; self.head</span><br><span class="line">        if p.right:</span><br><span class="line">            #如果head节点的右边不为NOne</span><br><span class="line">            #说明栈中已经有元素了</span><br><span class="line">            #就执行下列的操作</span><br><span class="line">            temp &#x3D; p.right</span><br><span class="line">            p.right &#x3D; newnode</span><br><span class="line">            newnode.next &#x3D; temp  #队列和栈的区别，一个链表正接，一个链表反接</span><br><span class="line">        else:</span><br><span class="line">            #这说明队列为空，插入第一个元素</span><br><span class="line">            p.right &#x3D; newnode</span><br><span class="line">            p.left &#x3D; newnode</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        #取出一个元素</span><br><span class="line">        p &#x3D; self.head</span><br><span class="line">        if p.left and (p.left &#x3D;&#x3D; p.right):</span><br><span class="line">            #说明栈中已经有元素</span><br><span class="line">            #但是这是最后一个元素</span><br><span class="line">            temp &#x3D; p.left</span><br><span class="line">            p.left &#x3D; p.right &#x3D; None</span><br><span class="line">            return temp.value</span><br><span class="line">        elif p.left and (p.left !&#x3D; p.right):</span><br><span class="line">            #说明栈中有元素，而且不止一个</span><br><span class="line">            temp &#x3D; p.right</span><br><span class="line">            p.right &#x3D; temp.next</span><br><span class="line">            return temp.value</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            #说明栈为空</span><br><span class="line">            #抛出查询错误</span><br><span class="line">            raise LookupError(&#39;queue is empty!&#39;)</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        if self.head.left:</span><br><span class="line">            return False</span><br><span class="line">        else:</span><br><span class="line">            return True</span><br><span class="line"></span><br><span class="line">    def bottom(self):</span><br><span class="line">        #查询目前栈中栈底元素</span><br><span class="line">        if self.head.left:</span><br><span class="line">            return self.head.left.value</span><br><span class="line">        else:</span><br><span class="line">            raise LookupError(&#39;queue is empty!&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h2><p>list实现：入队列加入队尾，出队列从头部拿取元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Queue(object):</span><br><span class="line">    def __init__(object):</span><br><span class="line">        self.stack &#x3D; []</span><br><span class="line"></span><br><span class="line">    def enqueue(self, value):</span><br><span class="line">        self.stack.append(value)</span><br><span class="line"></span><br><span class="line">    def dequeue(self):</span><br><span class="line">        if self.stack:</span><br><span class="line">            self.stack.pop(0)</span><br><span class="line">        else:</span><br><span class="line">            raise LookupError(&#39;stack is empty!&#39;)</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return bool(self.stack)</span><br><span class="line"></span><br><span class="line">    def top(self):</span><br><span class="line">        return self.queue[0]</span><br></pre></td></tr></table></figure>
<p>链表实现:<br>定义一个头结点，左边指向队列的开头，右边指向队列的末尾，这样就可以保证我们插入一个元素和取出一个元素都是O(1)的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class Head(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line">class Node(object):</span><br><span class="line">    def __init__(self, value):</span><br><span class="line">        self.value &#x3D; value</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Queue(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        #初始化节点</span><br><span class="line">        self.head &#x3D; Head()</span><br><span class="line"></span><br><span class="line">    def enqueue(self, value):</span><br><span class="line">        #插入一个元素</span><br><span class="line">        newnode &#x3D; Node(value)</span><br><span class="line">        p &#x3D; self.head</span><br><span class="line">        if p.right:</span><br><span class="line">            #如果head节点的右边不为NOne</span><br><span class="line">            #说明队列中已经有元素了</span><br><span class="line">            #就执行下列的操作</span><br><span class="line">            temp &#x3D; p.right</span><br><span class="line">            p.right &#x3D; newnode</span><br><span class="line">            temp.next &#x3D; newnode</span><br><span class="line">        else:</span><br><span class="line">            #这说明队列为空，插入第一个元素</span><br><span class="line">            p.right &#x3D; newnode</span><br><span class="line">            p.left &#x3D; newnode</span><br><span class="line"></span><br><span class="line">    def dequeue(self):</span><br><span class="line">        #取出一个元素</span><br><span class="line">        p &#x3D; self.head</span><br><span class="line">        if p.left and (p.left &#x3D;&#x3D; p.right):</span><br><span class="line">            #说明队列中已经有元素</span><br><span class="line">            #但是这是最后一个元素</span><br><span class="line">            temp &#x3D; p.left</span><br><span class="line">            p.left &#x3D; p.right &#x3D; None</span><br><span class="line">            return temp.value</span><br><span class="line">        elif p.left and (p.left !&#x3D; p.right):</span><br><span class="line">            #说明队列中有元素，而且不止一个</span><br><span class="line">            temp &#x3D; p.left</span><br><span class="line">            p.left &#x3D; temp.next</span><br><span class="line">            return temp.value</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            #说明队列为空</span><br><span class="line">            #抛出查询错误</span><br><span class="line">            raise LookupError(&#39;queue is empty!&#39;)</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        if self.head.left:</span><br><span class="line">            return False</span><br><span class="line">        else:</span><br><span class="line">            return True</span><br><span class="line"></span><br><span class="line">    def top(self):</span><br><span class="line">        #查询目前队列中最早入队的元素</span><br><span class="line">        if self.head.left:</span><br><span class="line">            return self.head.left.value</span><br><span class="line">        else:</span><br><span class="line">            raise LookupError(&#39;queue is empty!&#39;)</span><br></pre></td></tr></table></figure>

<h1 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h1><h2 id="Stack-2"><a href="#Stack-2" class="headerlink" title="Stack"></a>Stack</h2><p>查看括号的完整性：<br>给定由前后括号组成的字符串，判断这个括号串是否合法。<br>思路：遍历字符串，如果是左括号则入栈，右括号则出栈一个，如果最后栈为空，则合法。</p>
<h2 id="Queue-2"><a href="#Queue-2" class="headerlink" title="Queue"></a>Queue</h2><p>窗口内最大最小值的更新结构：</p>
<p>给定一个数组，和一个更新窗口，大小为k，当窗口从头到尾滑动时，不断更新窗口内的最大最小值。</p>
<p>思路：</p>
<p>利用双端队列来解决这个问题，双端队列，两端都可以出队，但只有队尾可以入队，java中由双向链表实现。</p>
<p><strong>窗口内最大值和最小值的更新结构：双端队列（双向链表），查询窗口内的最大或最小值为O(1)操作。将窗口元素从大到小排列的位置加入这个双端队列。</strong></p>
<p><strong>加入逻辑：新元素试图从尾部进，如果值小于当前尾部，则将其位置加入双端队列，否则从尾部弹出元素（相等也弹出），直到该元素可以从尾部加入）。</strong></p>
<p><strong>退出逻辑：当一个元素弹出窗口时，看这个数的位置是否是双端队列的头，如果是，就从头弹出。</strong></p>
<p><strong>该队列永远保证头是当前窗口内最大值的位置，如果要保存最小值，再建立一个递增序排列的双端队列。</strong></p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Shuchen</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>