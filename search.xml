<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Dubbo 入门笔记2</title>
      <link href="/2020/05/30/dubbo-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02/"/>
      <url>/2020/05/30/dubbo-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍dubbo的核心概念，架构和相关组件的搭建</p><a id="more"></a><h1 id="dubbo核心概念"><a href="#dubbo核心概念" class="headerlink" title="dubbo核心概念"></a>dubbo核心概念</h1><p>dubbo是一款高性能的Java RPC框架</p><h2 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h2><ol><li>面向接口代理的高性能RPC调用（直接调用接口即可，屏蔽了远程调用的细节）</li><li>只能负载均衡（能根据服务器的压力智能分配远程调用哪台）</li><li>服务自动注册与发现（支持多种注册中心，实时感知服务的上下线）</li><li>运行时流量调度（配置不同的路由规则来决定调用哪些服务器的服务，测试版服务只在部分服务器上部署，初期只将特定的请求提交到新版的服务器，方便测试，便于灰度发布）</li><li>可视化的运维</li><li>高扩展性</li></ol><p>灰度发布：在新版软件写好后只在部分服务器上部署，待测试稳定后逐渐曾多部署的个数，直到所有服务器都部署了新版本</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>注册中心（registry）：所有服务器上负责的业务逻辑都要注册在注册中心上，当一台服务器需要远程调用其他服务器的业务时，先去注册中心查找都有哪些服务器负责这个业务。类似一个清单，上面记录每台服务器负责的业务是什么。注册中心负责将请求分配给合适的服务器。</p><p>提供者（provider）：提供服务方，RPC中的B服务器</p><p>消费者（customer）：调用服务方，RPC中的A服务器</p><p>容器（container）：dubbo框架的容器</p><p>监控中心（monitor）：提供者和消费者的监控信息</p><p>流程：容器启动dubbo框架—&gt; 提供者将所有服务注册到注册中心—&gt;消费者在注册中心订阅（查找）需要的服务，如果服务提供者有变动，注册中心也会通知消费者（基于长连接）—&gt;消费者调用服务（根据负载均衡分配到具体的一台服务器）—&gt;监控中心接收并记录监控信息</p><h2 id="注册中心搭建"><a href="#注册中心搭建" class="headerlink" title="注册中心搭建"></a>注册中心搭建</h2><p>dubbo支持多种注册中心，推荐使用zookeeper</p><p>win下安装zookeeper：</p><ol><li><a href="http://zookeeper.apache.org/releases.html">zookeeper 官网</a>下载稳定版本</li><li>解压，复制conf文件夹下的zoo_sample.cfg,重命名为zoo.cfg</li><li>将zoo.cfg里临时数据的目录更改为自己创建的文件夹（12行datadir）</li><li>在bin目录下用命令行启动即可（zkServer.cmd）</li><li>可用zkCli.cmd来测试是否启动成功</li></ol><p>zookeeper详细内容见相关笔记</p><h2 id="监控中心搭建"><a href="#监控中心搭建" class="headerlink" title="监控中心搭建"></a>监控中心搭建</h2><ol><li>在<a href="https://github.com/apache/dubbo">dubbo github</a>找到<a href="https://github.com/apache/dubbo-admin">dubbo admin</a></li><li>下载这个dubbo admin 项目并用maven构建</li><li>修改“dubbo-admin\src\main\resources” 下的application.properties,确保zookeeper的端口号正确（默认为：dubbo.registry.address=zookeeper://127.0.0.1:2181）</li><li>在dubbo-admin下用mvn命令打jar包：mvn clean package （确保maven已安装）</li><li>成功后再target文件夹里就会有生成的jar包，将此jar包移动到想要的位置，然后用java启动即可（java -jar jar包名.jar）</li><li>启动后dubbo监控会再7001端口启动</li><li>网站账号和密码都是root</li><li>注意，在启动之前先启动zookeeper才行</li></ol><h2 id="创建服务提供者"><a href="#创建服务提供者" class="headerlink" title="创建服务提供者"></a>创建服务提供者</h2><p>提供者和消费者都是服务器上的Java工程，比如两个springboot工程，现利用dubbo实现两个工程之间的RPC通信。</p><p>由于不同工程之间需要进行通信，dubbo推荐将所有接口和bean单独存放成一个工程，在其他工程的maven中引入这个接口专用工程即可。</p><p>对于提供者：</p><p>将服务提供者注册到注册中心（暴露服务）</p><ol><li><p>maven中导入dubbo依赖（去maven仓库搜索，将对应的dependency加入pom.xml）</p></li><li><p>引入操作zookeeper的客户端<a href="https://mvnrepository.com/artifact/org.apache.curator/curator-framework">Curator Framework</a> （dubbo2.6版本后开始使用）</p></li><li><p>用spring配置服务提供者，在<a href="https://dubbo.apache.org/zh-cn/docs/user/quick-start.htm">官网</a>找到provider.xml文件，再resource里参照其编写自己的配置文件</p><ol><li>指定当前服务/应用的名字（同样服务的名字相同，不要重名）</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;hello-world-app&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>指定注册中心的位置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://224.5.6.7:1234&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>指定通信规则（协议，端口）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>暴露服务，ref指向服务真正的实现对象</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>服务的实现</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.dubbo.demo.provider.DemoServiceImpl&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>加载spring配置，运行下面代码，可以发现在监控中心会多出刚刚配置的服务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123;<span class="string">&quot;http://10.20.160.198/wiki/display/dubbo/provider.xml&quot;</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read(); <span class="comment">// 按任意键退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建服务的消费者"><a href="#创建服务的消费者" class="headerlink" title="创建服务的消费者"></a>创建服务的消费者</h2><ol><li><p>同理maven引入dubbo框架和zookeeper的操作</p></li><li><p>用spring配置消费者</p><ol><li>指定名字</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;consumer-of-helloworld-app&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>指定注册中心的地址</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://224.5.6.7:1234&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>声明需要调用的远程服务的接口，生成远程服务代理</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>加载spring配置，调用远程服务，运行代码可以发现调用成功，并且监控中心有一个消费者，一个提供者</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.DemoService;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123;<span class="string">&quot;http://10.20.160.198/wiki/display/dubbo/consumer.xml&quot;</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        DemoService demoService = (DemoService)context.getBean(<span class="string">&quot;demoService&quot;</span>); <span class="comment">// 获取远程服务代理</span></span><br><span class="line">        String hello = demoService.sayHello(<span class="string">&quot;world&quot;</span>); <span class="comment">// 执行远程方法</span></span><br><span class="line">        System.out.println( hello ); <span class="comment">// 显示调用结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监控中心安装及配置"><a href="#监控中心安装及配置" class="headerlink" title="监控中心安装及配置"></a>监控中心安装及配置</h2><p>dubbo admin——管理控制台，图形化界面，可获得所有提供者、消费者（已完成，详见<a href="https://chekey30.github.io/2020/02/19/dubbo-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/">dubbo 入门笔记1</a>）</p><p>dubbo-monitor-simple——简单的监控中心（此处讨论其安装和配置）</p><ol><li><p>git下载相关组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;incubator-dubbo-ops</span><br></pre></td></tr></table></figure><p>下载后dubbo-monitor-simple就是简易的监控中心</p></li><li><p>修改配置<br> 在 dubbo-admin-master\dubbo-monitor-simple\target\classes\conf 下有dubbo.properties文件，在其中可修改端口号等配置，保证注册中心的地址正确</p></li><li><p>启动简易的监控中心<br>在 dubbo-admin-master\dubbo-monitor-simple\target\classes\META-INF\assembly\bin 目录下为可执行的脚本，运行start.bat即可启动</p></li><li><p>配置消费者和提供者连接监控中心<br>在之前的spring配置中加入dubbo:monitor的配置，具体信息参考<a href="https://dubbo.apache.org/zh-cn/docs/user/references/xml/introduction.html">schema 配置参考手册</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK 源码学习笔记 1</title>
      <link href="/2020/03/25/JDK-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2020/03/25/JDK-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从本文开始对JDK源码进行学习，内容包含Java中各种常见数据结构的底层实现原理和其他重要的Java函数的底层实现。本文包括JDK源码阅读环境搭建</p><a id="more"></a><h1 id="创建Java源码学习项目"><a href="#创建Java源码学习项目" class="headerlink" title="创建Java源码学习项目"></a>创建Java源码学习项目</h1><ol><li>在idea中创建一个新的Java项目，起名为JavaSourceCodeLearn</li><li>在setting中将如下选项取消勾选，否则逐步调试时无法进入底层类</li></ol><img src="/2020/03/25/JDK-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/debugging.PNG" class="" title="取消勾选"><h1 id="更换源码路径"><a href="#更换源码路径" class="headerlink" title="更换源码路径"></a>更换源码路径</h1><ol><li>在JDK保存的文件家中有src的压缩包（JDK8以前在JDK文件夹下，之后则在lib文件夹下）</li><li>将该src解压到某个文件夹内，记住这个路径</li><li>在项目的SDKs选项内将Sourcepath内的所有源替换为上一步创建的文件夹（这样做的目的是让我们能够给源码添加自己的注释）</li></ol><img src="/2020/03/25/JDK-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/source.PNG" class="" title="更改源"><h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><p>不要把复制的源码放在项目路径下，否则会引起错误</p><h1 id="源码学习顺序"><a href="#源码学习顺序" class="headerlink" title="源码学习顺序"></a>源码学习顺序</h1><p>重要的部分都在java.base-&gt;java文件夹内</p><p>1、java.lang</p><ol><li>Object 1</li><li>String 1</li><li>AbstractStringBuilder 1</li><li>StringBuffer 1</li><li>StringBuilder 1</li><li>Boolean 2</li><li>Byte 2</li><li>Double 2</li><li>Float 2</li><li>Integer 2</li><li>Long 2</li><li>Short 2</li><li>Thread 2</li><li>ThreadLocal 2</li><li>Enum 3</li><li>Throwable 3</li><li>Error 3</li><li>Exception 3</li><li>Class 4</li><li>ClassLoader 4</li><li>Compiler 4</li><li>System 4</li><li>Package 4</li><li>Void 4</li></ol><p>2、java.util</p><ol><li>AbstractList 1</li><li>AbstractMap 1</li><li>AbstractSet 1</li><li>ArrayList 1</li><li>LinkedList 1</li><li>HashMap 1</li><li>Hashtable 1</li><li>HashSet 1</li><li>LinkedHashMap 1</li><li>LinkedHashSet 1</li><li>TreeMap 1</li><li>TreeSet 1</li><li>Vector 2</li><li>Queue 2</li><li>Stack 2</li><li>SortedMap 2</li><li>SortedSet 2</li><li>Collections 3</li><li>Arrays 3</li><li>Comparator 3</li><li>Iterator 3</li><li>Base64 4</li><li>Date 4</li><li>EventListener 4</li><li>Random 4</li><li>SubList 4</li><li>Timer 4</li><li>UUID 4</li><li>WeakHashMap 4</li></ol><p>3、java.util.concurrent</p><ol><li>ConcurrentHashMap 1</li><li>Executor 2</li><li>AbstractExecutorService 2</li><li>ExecutorService 2</li><li>ThreadPoolExecutor 2</li><li>BlockingQueue 2<br>7）AbstractQueuedSynchronizer 2<br>8）CountDownLatch 2</li><li>FutureTask 2<br>10）Semaphore 2<br>11）CyclicBarrier 2<br>13）CopyOnWriteArrayList 3<br>14）SynchronousQueue 3<br>15）BlockingDeque 3</li><li>Callable 4</li></ol><p>4、java.util.concurrent.atomic</p><ol><li>AtomicBoolean 2</li><li>AtomicInteger 2</li><li>AtomicLong 2</li><li>AtomicReference 3</li></ol><p>5、java.lang.reflect</p><ol><li>Field 2</li><li>Method 2</li></ol><p>6、java.lang.annotation</p><ol><li>Annotation 3</li><li>Target 3</li><li>Inherited 3</li><li>Retention 3</li><li>Documented 4</li><li>ElementType 4</li><li>Native 4</li><li>Repeatable 4</li></ol><p>7、java.util.concurrent.locks</p><ol><li>Lock 2</li><li>Condition 2</li><li>ReentrantLock 2</li><li>ReentrantReadWriteLock 2</li></ol><p>8、java.io</p><ol><li>File 3</li><li>InputStream   3</li><li>OutputStream  3</li><li>Reader  4</li><li>Writer  4</li></ol><p>9、java.nio</p><ol><li>Buffer 3</li><li>ByteBuffer 4</li><li>CharBuffer 4</li><li>DoubleBuffer 4</li><li>FloatBuffer 4</li><li>IntBuffer 4</li><li>LongBuffer 4</li><li>ShortBuffer 4</li></ol><p>10、java.sql</p><ol><li>Connection 3</li><li>Driver 3</li><li>DriverManager 3</li><li>JDBCType 3</li><li>ResultSet 4</li><li>Statement 4</li></ol><p>11、java.net</p><ol><li>Socket 3</li><li>ServerSocket 3</li><li>URI 4</li><li>URL 4</li><li>URLEncoder 4</li></ol><p>阅读笔记简版<br>1、ArrayList</p><p>1）Object[] elementData：数据存储<br>2）int size：使用数量<br>3）int modCount：操作次数<br>4）初始化：<br>  a、指定容量初始化数组；<br>  b、不指定容量第一次add数据时初始化数组容量10<br>5）扩容：<br>  a、1.5倍；<br>  b、不够取所需最小；<br>  c、新容量大于MAX_ARRAY_SIZE（Integer.MAX_VALUE-8）,按所需容量取MAX_ARRAY_SIZE和Integer.MAX_VALUE较小值</p><p>2、LinkedList</p><ol><li>Node {E item, Node prev, Node next}</li><li>int size</li><li>Node first</li><li>Node last</li><li>linkFirst(), linkLast(), linkBefore(), unLinkFirst(), unLinkLast(), unLink(), indexOf()<br>6）int modCount</li></ol><p>3、HashMap</p><ol><li>Node{int hash, K key, V value, Node next}<br>注：hash是根据key算的</li><li>Node[] table：数据存储，默认大小16</li><li>Set&lt;Map.Entry&gt; entrySet：用于Map遍历的集合</li><li>int size：当前数量</li><li>int threshold：size超过多少时需要扩容，默认16</li><li>float loadFactor：负载因子，默认0.75f<br>7）int modCount：操作次数</li><li>put():根据key算hash，根据容量和hash算index，table[index]没有直接添加到数组中，table[index]有，若index位置同一个key则更新，否则遍历next是否有，有则更新，无则新增<br>注：判断key是否相等，先比较hash，若相等在比较equals<br>9）扩容：put后，当size&gt;threshold时需要扩容，扩容时容量翻倍，重新算hash复制到新数组<br>10）哈希冲突：1.7以前数组+链表，1.8开始数组+红黑树<br>11）get()类似</li></ol><p>4、ConcurrentHashMap</p><ol><li>JDK1.7及以前：<br> a、Segment[] ,HashEntry[] , HashEntry{hash, k, v, next}<br> b、根据key算hash，根据hash和Segment的大小算位置，每个segment拥有一个自己的HashEntry[]<br> c、get()：不加锁，volatile类型<br> d、put(): 对相应segment加锁<br> e、size()：各HashEntry[] 之和，先不加锁算两遍，若一致则返回，若不一致则加锁重新计算<br>2）JDK1.8<br> a、Node{hash, key, value, next}<br> b、Node[] table<br> c、大多数操作类似于HashMap，根据key算hash，在根据hash和容量算index，对table[index]加锁，从而达到更大的并发量<br> d、get(): 同HashMap<br> e、put(): 对table[index]加锁，如果table[index]为null则使用CAS操作，如果不为null对table[index]加synchronized</li></ol><p>5、Hashtable</p><ol><li>结构实现与HashMap基本一致</li><li>通过synchronized方法保证线程安全</li></ol><p>6、LinkedHashMap</p><p>1）继承HashMap<br>2) Entry{HashMap.Node, Entry before, after}<br>3) Entry head, tail<br>4) 重写newNode()添加节点时，除像HashMap中添加外，保存before、after信息</p><p>7、TreeMap</p><p>1）红黑树，即自平衡二叉查找树，时间复杂度O(logn)<br>2）Entry{K k, V v, Entry parent, left, right, boolean color}<br>3）Entry root，int size， int modeCount</p><p>8、Object</p><ol><li>wait(), notify(), notifyAll(), wait(timeout)</li><li>hashCode(), equals()</li><li>clone()</li></ol><p>9、String</p><ol><li>final char[] value</li><li>int hash</li><li>equals(), startWith(), endWith(), replace</li></ol><p>10、AbstractStringBuilder</p><ol><li>char[] value</li><li>int count</li><li>扩容：翻倍，不够取所需最小</li></ol><p>11、StringBuilder：继承AbstractStringBuilder<br>12、StringBuffer</p><ol><li>继承AbstractStringBuilder</li><li>synchronized方法保证线程安全</li><li>char[] toStringCache</li></ol><p>13、Set一般都是使用委托模式到Map<br>14、AbstractMap维护EntrySet，AbstractSet维护Iterator，AbstractList维护Iterator</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://blog.csdn.net/qq_21033663/article/details/79571506">https://blog.csdn.net/qq_21033663/article/details/79571506</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo 入门笔记1</title>
      <link href="/2020/02/19/dubbo-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"/>
      <url>/2020/02/19/dubbo-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录应用架构的发展，RPC的思想。</p><!-----------------------more------------------------------><h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><p>分布式系统是若干独立计算机的集合，这些计算机对用户来说是单个的相关系统。</p><p>直白解释：多台计算机负责不同的功能，相互交互，但对用户来说和用一台计算机没有区别。</p><p>单一服务器无法完成如此复杂和如此大量的需求（比如淘宝），因此将不同的功能拆分成不同的功能模块，分别部署在不同的服务器上。</p><h1 id="应用架构的发展"><a href="#应用架构的发展" class="headerlink" title="应用架构的发展"></a>应用架构的发展</h1><img src="/2020/02/19/dubbo-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/dubbo1.png" class="" title="架构发展"><h2 id="单一架构应用"><a href="#单一架构应用" class="headerlink" title="单一架构应用"></a>单一架构应用</h2><p>所有的功能模块全部写在一个程序之中，打包成一个包，部署在一个服务器上。当流量不大，功能简单时方便好用。如果流量增大，则服务器无法承受。当功能复杂时，即使部署多台服务器，每一台也无法承受。</p><p>难以扩展，难以协同和维护（任何小的改动都需要在所有服务器上更改）</p><h2 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h2><p>将程序拆分成几块<strong>互不相关</strong>的独立应用，分别部署，并且将压力大的部分多部署几台。</p><p>无法做到界面和业务逻辑的分离，每次页面的小改动都需要重新部署</p><p>应用不可能完全独立，大量的应用之间需要交互。</p><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><p>将应用的核心业务抽取出来，前后端分离。有的服务器专门部署各个界面，其他服务器分别部署应用的不同核心业务逻辑，之间进行交互。</p><p>之前同一业务在同一服务器上，进行的是进程内通讯，现在的交互是不同服务器间的，称为远程过程调用remote procedure call（RPC）。</p><p>分布式架构的难点在于如何进行RPC和如何拆分业务以减少重复。</p><p>无法进行动态调控，由于部署各个业务的服务器个数是一定的，会造成压力大的业务服务器不够，压力小的业务服务器闲置浪费</p><h2 id="流动计算架构-SOA（Service-Oriented-Architecture）"><a href="#流动计算架构-SOA（Service-Oriented-Architecture）" class="headerlink" title="流动计算架构 SOA（Service-Oriented Architecture）"></a>流动计算架构 SOA（Service-Oriented Architecture）</h2><p>引入调度中心，负责维护服务间的复杂关系，实时管理服务集群，给访问量大的业务多分配服务器。并且平衡跑相同业务的服务器上的请求个数。</p><h1 id="RPC（remote-procedure-call）"><a href="#RPC（remote-procedure-call）" class="headerlink" title="RPC（remote procedure call）"></a>RPC（remote procedure call）</h1><img src="/2020/02/19/dubbo-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/dubbo1-2.PNG" class="" title="RPC原理"><p>一种进程间的通信方式，是思想而不是规范。（类比JVM是一种思想，各种JVM的实现就是规范）</p><p>A服务器要调用B服务器上的方法，A上的stub通过网络和B建立连接并且传出相关的参数，之后B上的stub接受参数，执行相应的方法，将操作的结果传回给A。通过stub的帮助，表面上调用远程方法和调用本地方法没有差别。</p><p>对于实现这种RPC思想的RPC框架，<strong>通信效率</strong>和<strong>序列化反序列化效率</strong>是两个评判标准。</p><p>常见的RPC框架：dubbo， gRPC，Thrift，HSF</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL笔记之三事务的隔离级别</title>
      <link href="/2019/12/20/MySQL%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>/2019/12/20/MySQL%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录MySQL事务隔离级别的相关知识，包括四种隔离级别，默认级别，不同存储引擎采用的锁。</p><!-------------------more----------------><h1 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h1><p>事务是由一组sql语句组成的逻辑处理单元，具有ACID的属性</p><ul><li>Atomicity（原子性）：一個事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被<a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BB%9A_(%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86)">回滚</a>（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7">约束</a>、<a href="https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93)">触发器</a>、<a href="https://zh.wikipedia.org/wiki/%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A">级联回滚</a>等。</li><li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><p>事务a和事务b之间有一定的隔离性</p><p>隔离性有隔离级别（4个）：</p><ol><li>读未提交 read uncommitted</li><li>读已提交 read committed</li><li>可重复读 repeatable</li><li>串行化 serializable</li></ol><p>隔离级别递增</p><p>read uncommitted 最低级别的隔离，a事务未提交的数据事务b可以读取到（脏读），一般理论存在</p><p>数据库默认的隔离级别一般高于此。读取的是内存里的数据</p><p>read committed 事务a提交的数据事务b才能读取到，可避免脏读，但是导致不可重复读取（事务b每次读取事务a的数据都不同，因为a提交了新的数据）不符合隔离性，读取的是硬盘里的数据。oracle默认的隔离级别。</p><p>repeatable：可重复读取，事务a提交了，事务b仍然读取不到。事务b可重复读取数据（每次拿到的都是事务a提交前的数据），b读取的是内存里自己存的a的数据。<strong>MySQL默认的隔离级别</strong>。会导致幻象读（事务结束后再次读取会有很大差异）</p><p>MVCC（多版本并发控制）机制：可重复读的隔离级别下使用了MVCC机制，select不会更新版本号，是快照读（自己内存里的数据），但所有更新操作会更新版本号，是当前读。</p><p>serializable：事务a在操作表中数据的时候，事务b只能等待。很少使用，吞吐量太低。</p><p>解决幻读问题：java代码同步并发、mysql间隙锁：通过where条件给表中的多条数据添加行锁，即使这条数据还不存在，也会加锁，这样操作，则其他session不能更新这几条数据，当前session读取出的数据一定是真实的。</p><h1 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h1><p>乐观锁：用版本对比实现数据更新，如果一个线程更新一个数据时发现此时的版本和自己查询到的版本不同（即该数据已经被其他线程更新过了）则更新失败。线程更新数据成功会增加数据的版本。</p><p>悲观锁：只允许一个线程访问数据。</p><p>表锁（对一张表加锁，分读和写锁，偏读）：</p><p><strong>MYISAM采用表锁，不支持事务</strong></p><p>加读锁：当前session和其他session都可以读这张表，当前session中插入或更新表会报错，其他session更新数据会被阻塞。（即不让任何session在当前session读取完表之前更改）</p><p>加写锁：当前session可进行任何操作，其他session全部阻塞。（即当前session更新完毕前不让任何其他session访问该表）</p><p>MYISAM 会在执行select时给对应表加读锁，在更改前加写锁。</p><p>行锁（对一行数据加锁，偏写）：</p><p><strong>InnoDB采用行锁，支持事务。</strong></p><p>在当前session更新一行数据，如果没有提交，则此时其他session不能更新这条数据，会阻塞。只有这个session的事务commit之后，才能更新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL笔记之二索引建立和优化</title>
      <link href="/2019/12/20/MySQL%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E5%92%8C%E4%BC%98%E5%8C%96/"/>
      <url>/2019/12/20/MySQL%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E5%92%8C%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文讨论MySQL中索引的建立方式和优化原则</p><!----------------------more-------------------------------------><h1 id="索引的建立"><a href="#索引的建立" class="headerlink" title="索引的建立"></a>索引的建立</h1><p>上一篇文章中讲述了MySQL的存储结构为B+树，因此，建立索引就是建立B+树的过程。对一张MySQL的表格而言，一般存在一个主键，则以主键为关键字建立B+树就是最基本的一种。除此以外，还可以针对非主键字段建立B+树来加快搜索。还可以针对多个字段建立索引，称为联合索引。</p><h2 id="非主键索引的底层数据结构"><a href="#非主键索引的底层数据结构" class="headerlink" title="非主键索引的底层数据结构"></a>非主键索引的底层数据结构</h2><p>在nnoDB中，对于一个非主键索引，同样建立b+树，</p><p>不同点是，<strong>叶子节点的元素不是整个数据，而是主键的值</strong>。因此通过非主键索引来查询会进行两次，先找到主键值，再去主键索引里找</p><p>优点：节省空间，保证一致性（如果每个索引都保存全部值，则按不同索引更新时就会出现不同）</p><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>按照多个字段建立索引，此时顺序尤为重要。比如有三个字段来做索引，emp_no，title，from_date，则搜索时会先按第一个字段找，相同再按第二个，还相同按第三个。因此，联合索引只能按顺序使用，不能跳用。（如果不用第一个，就不能用第二个）</p><img src="/2019/12/20/MySQL%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E5%92%8C%E4%BC%98%E5%8C%96/combindex.PNG" class="" title="MySQL笔记之二索引建立和优化"><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><img src="/2019/12/20/MySQL%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E5%92%8C%E4%BC%98%E5%8C%96/indexq1.PNG" class="" title="MySQL笔记之二索引建立和优化"><p>分析：</p><p>总共建立了三个索引，是联合索引，分别为emp_no，title，from_date</p><ol><li>会用到索引的三个字段</li><li>不会用索引(没用第一个字段，直接用了第二个字段)</li><li>会用索引</li><li>会用一个</li><li>会用</li></ol><h1 id="索引优化原则"><a href="#索引优化原则" class="headerlink" title="索引优化原则"></a>索引优化原则</h1><h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><p>由于联合索引会先按第一个字段比较，然后第二，然后第三。因此，如果查询语句的查询条件里没有第一个字段，只有二三，则不会运用联合索引。会遍历表逐行判断。</p><p>同理，只有1,3字段也不行。想用联合索引，查询语句的判断条件中必须包含从第一个字段开始的连续字段。</p><p>这就是最左前缀法则。即联合索引用了三个字段abc，则查询条件也要是a=，b=，c=或者a=，b=。即<strong>查询条件顺序必须和联合索引顺序相同</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL笔记之一 存储结构，存储引擎</title>
      <link href="/2019/12/18/MySQL%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2019/12/18/MySQL%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录MySQL底层的存储数据结构和存储引擎。</p><!--------------more----------------><h1 id="MySQL存储结构"><a href="#MySQL存储结构" class="headerlink" title="MySQL存储结构"></a>MySQL存储结构</h1><p>从需求的角度出发来考虑可以用的数据结构。对于数据库来说，最重要的功能就是要快速找到需要的数据。因此，线性的存储结构比如数组，链表等都不做考虑，用遍历的方式找到数据太过缓慢。可用的数据结构有哈希表，搜索二叉树，红黑树，b树，b+树等。下面逐一分析优劣来理解为什么MySQL选择了b+树作为存储结构。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表的特点是能够在O(1)的时间复杂度内找到所需的元素。其原理是将键值对的键利用哈希函数转换，变成等长的形式，之后存在相应的内存地址上，之后查询的时候就对键做同样操作，然后去内存上找到对应位置即可。</p><p>优点：查找快速</p><p>缺点：</p><ol><li>数据量过大时哈希冲突会很多，此时每个地址下存入的都是一个红黑树，查找也会变慢。</li><li>只能做精确查找，无法完成范围查找</li></ol><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>搜索二叉树是一种特殊的二叉树，对每一个节点，若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</p><p>优点：可以做范围查找，查询速度为O(logn)</p><p>缺点：</p><ol><li>如果维护的字段是递增的，则生成的二叉树很不平衡（只有右子），此时查找仍是O(n)</li><li>大量数据会造成深度过深，此时搜索仍旧很慢</li></ol><p>对于第一点的优化可以使用红黑树，但仍旧无法解决第二个缺点</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树是一种平衡树，即每个叶结点的深度相同，以此来防止非平衡树带来的查询复杂度不同的问题，同时每个节点可以存储多个数据，解决深度过深的问题。具体定义以下概念：</p><ol><li>度：指节点存储的数据个数</li><li>阶：指节点最多能存储的数据个数</li></ol><p>对于一颗m阶的B树，其满足：</p><ol><li>每个结点最多有m-1个关键字。</li><li>根结点最少可以只有1个关键字。</li><li>非根结点至少有Math.ceil(m/2)-1个关键字。</li><li>每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。</li></ol><img src="/2019/12/18/MySQL%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/btree.PNG" class="" title="MySQL笔记之一 存储结构，存储引擎"><p>具体的插入删除操作参考：<a href="https://www.cnblogs.com/nullzx/p/8729425.html">https://www.cnblogs.com/nullzx/p/8729425.html</a></p><p>具体的动画演示：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p><p>优点：解决了大量数据的存储和查询问题</p><p>缺点：每个节点能够存储的元素有限。MySQL需要将节点读入内存来进行查找工作，由于每个节点包含关键字（key）和所有值（value），因此内存限制了一次无法读入很多节点，降低搜索效率。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>和B树类似，有两点不同</p><ol><li>所有的值都存在叶子节点，非叶子节点只存储关键字</li><li>叶子节点之间用指针连接，方便范围查找</li></ol><p>m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。</p><p>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都<strong>小于</strong>它，右子树中的key都<strong>大于等于</strong>它。叶子结点中的记录也按照key的大小排列。</p><img src="/2019/12/18/MySQL%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/b+tree.PNG" class="" title="MySQL笔记之一 存储结构，存储引擎"><p>动画演示：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p><p>优点：满足大量数据快速查询，由于非叶子节点只存索引，可以一次尽可能多的加载索引进入内存，加快查找。同时叶子节点之间的指针加快范围查找。</p><p>mysql底层bigint类的索引占8字节，指针占6字节，默认每个索引字段的大小为16kb（每个节点就是一个索引字段），由此得出，每个索引字段可以存大概1000个元素（索引）</p><h1 id="MySQL-的搜素引擎"><a href="#MySQL-的搜素引擎" class="headerlink" title="MySQL 的搜素引擎"></a>MySQL 的搜素引擎</h1><p>先明确一点，MySQL的存储引擎是用来<strong>形容表的，不是数据库</strong>。它决定了一张表是如何存储在硬盘上的。</p><p>常见的存储引擎有MYISAM和InnoDB。</p><h2 id="MYISAM"><a href="#MYISAM" class="headerlink" title="MYISAM"></a>MYISAM</h2><p>对于每张表，MYISAM有三个文件：.MYD , .MYI, .frm</p><p>frm 是表结构定义的文件</p><p>MYD是数据的存储</p><p>MYI是索引的存储，主键是自带索引的。</p><img src="/2019/12/18/MySQL%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/b+tree.PNG" class="" title="MySQL笔记之一 存储结构，存储引擎"><p>拿到需要的索引，进入MYI文件通过b+树定位，找到对应的指针（myiSAM），在用这个指针去MYD文件里定位到对应的位置。</p><p>是非聚集索引（数据和索引分开存储）</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>INNODB的存储只有两个文件.frm和.ibd</p><p>其中ibd保存索引和数据，不用指针来定位，直接把索引和数据存在一起</p><img src="/2019/12/18/MySQL%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/indexstore.PNG" class="" title="MySQL笔记之一 存储结构，存储引擎"><p>表数据本身就是按照b+树结构来存储的</p><p><strong>聚集索引：叶子节点包含了完整的数据记录</strong></p><p>innoDB必须要建立主键来组织b+树，并且推荐用自增整形来做主键，因为1.节约存储空间2.搜素过程需要比大小</p><p>3.自增是因为b+树必须维护元素有序，当插入的元素不是结尾元素时，b+树已经生成的结构可能需要重构（之前的一个索引字段已经满了，又要插入一个，则这个字段必须分裂）</p><p>叶子节点之间的指针（双向指针）：用来进行范围查找，找到边界的节点，之后利用这个指针找到左右需要的范围</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manacher</title>
      <link href="/2019/08/31/Manacher/"/>
      <url>/2019/08/31/Manacher/</url>
      
        <content type="html"><![CDATA[<h1 id="Manacher-求最长回文子串"><a href="#Manacher-求最长回文子串" class="headerlink" title="Manacher: 求最长回文子串"></a>Manacher: 求最长回文子串</h1><p>该算法用于求最长回文字串，可在O(n)内求出一个字符串的最长回文字串，暴力做法需要O(n^2)的时间。主要运用动态规划的思想，之前求过的信息（以某个位置为对称中心的最长回文半径）在之后可以被反复运用，无需再求一次。</p><!-----------------------------------------more-----------------------------><h1 id="具体做法："><a href="#具体做法：" class="headerlink" title="具体做法："></a>具体做法：</h1><ol><li>先将字符串预处理，取消奇偶字符串的差异，具体做法是在当前字符串的每个字符间隔内插入一个不会出现在字符串中的符号，比如#。</li><li>构造一个和字符串等长的数组dp，dp[i]表示以i为对称轴的最长回文的回文半径。最终结果就是dp中最大值-1。</li><li>同时维护一个maxright和idx，分别表示当前探查到的形成回文的最右边的位置maxright和以该位置结尾的回文的中心idx。</li><li>遍历数组，当到达i位置时，i位置肯定在idx右边。有两种情况 (1) i位置超过了maxright，则当前保存的已知信息已经没用了，直接以i为中心左右比对去找到最大的回文，之后更新maxright和idx。(2) i没有超过maxright，则找到和i关于idx对称的位置j，j=2*idx-i。可以直接读取出dp[j]。又分两种情况，(a) j做对称轴的最长回文半径大于i到maxright的距离，此时只能确定i到maxright的部分是回文的，因此从maxright+1位置开始，以i为中心左右比对。（b）j做对称轴的最长回文半径小于等于i到maxright的距离，此时i至少也用于同样的半径，因此从这个半径的下一位开始探查。结束后更新maxright和idx。</li><li>遍历结束，找到dp中的最大值，由于字符串经过了处理，这里的最大半径-1刚好就是原串的最长回文。</li></ol><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><p>python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">s</span>):</span></span><br><span class="line">       s = <span class="string">&quot;#&quot;</span>+<span class="string">&quot;#&quot;</span>.join(s)+<span class="string">&quot;#&quot;</span></span><br><span class="line">       dp = [<span class="number">0</span>]*len(s)</span><br><span class="line">       maxRight = <span class="number">0</span></span><br><span class="line">       idx =<span class="number">0</span></span><br><span class="line">       res = <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">           <span class="keyword">if</span> i&lt;maxRight:</span><br><span class="line">               dp[i] = min(dp[<span class="number">2</span>*idx-i],maxRight-i)</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               dp[i]=<span class="number">1</span></span><br><span class="line">           <span class="keyword">while</span> i-dp[i]&gt;=<span class="number">0</span> <span class="keyword">and</span> i+dp[i]&lt;len(s) <span class="keyword">and</span> s[i-dp[i]]==s[i+dp[i]]:</span><br><span class="line">               dp[i]+=<span class="number">1</span></span><br><span class="line">           <span class="keyword">if</span> dp[i]+i<span class="number">-1</span>&gt;maxRight:</span><br><span class="line">               maxRight=dp[i]+i<span class="number">-1</span></span><br><span class="line">               idx = i</span><br><span class="line">           res = max(res,dp[i])</span><br><span class="line">       <span class="keyword">return</span> res<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] tmp = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[tmp.length*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> j =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tmp.length;i++)&#123;</span><br><span class="line">        arr[j++]=tmp[i];</span><br><span class="line">        arr[j++]=<span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] dp = <span class="keyword">new</span> <span class="keyword">char</span>[arr.length];</span><br><span class="line">    <span class="keyword">int</span> maxright =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;maxright)&#123;</span><br><span class="line">            dp[i] = min(dp[<span class="number">2</span>*idx-i],maxright-i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i-dp[i]&gt;=<span class="number">0</span> &amp;&amp; i+dp[i]&lt;arr.length &amp;&amp; arr[i-dp[i]] == arr[i+dp[i]])&#123;</span><br><span class="line">            dp[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]+i&gt;maxright)&#123;</span><br><span class="line">            maxright = dp[i]+i-<span class="number">1</span>;</span><br><span class="line">            idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,dp[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h1><ol><li>有时候要求求出具体的最长子回文是什么，此时结果不再记录数子，而是记录最长的对称轴和半径idx和r，则在变换字符串中idx-r+1到idx+r-1之间就是最长回文字串，取到，去标记#即可。</li><li>有时候不需要连续，只要是子集（子序列）即可，则转化为一道动态规划的问题，不用这个算法解。</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://segmentfault.com/a/1190000003914228#articleHeader3">https://segmentfault.com/a/1190000003914228#articleHeader3</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree</title>
      <link href="/2019/08/31/Tree/"/>
      <url>/2019/08/31/Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><strong>二叉树</strong>：二叉树是有限个结点的集合，这个集合或者是空集，或者是由一个根结点和两株互不相交的二叉树组成，其中一株叫根的做左子树，另一棵叫做根的右子树。</p><p><strong>二叉树的性质</strong>：</p><ul><li>性质1：在二叉树中第 i 层的结点数最多为2^(i-1)（i ≥ 1）</li><li>性质2：高度为k的二叉树其结点总数最多为2^k－1（ k ≥ 1）</li><li>性质3：对任意的非空二叉树 T ，如果叶结点的个数为 n0，而其度为 2 的结点数为 n2，则：<code>n0 = n2 + 1</code></li></ul><p><strong>满二叉树</strong>：深度为k且有2^k －1个结点的二叉树称为满二叉树</p><p><strong>完全二叉树</strong>：深度为 k 的，有n个结点的二叉树，当且仅当其每个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应，称之为完全二叉树。（除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点）</p><ul><li>性质4：具有 n 个结点的完全二叉树的深度为 log2n + 1</li></ul><p><strong>注意</strong>：</p><ul><li>仅有前序和后序遍历，不能确定一个二叉树，必须有中序遍历的结果</li></ul><!-----------------------------more----------------------------------------><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（如果有的话） 的元素，则称此完全二叉树为最大堆。</p><p>同样，如果一棵完全二叉树的任意一个非终端结点的元素都不大于其左儿子结点和右儿子结点（如果 有的话）的元素，则称此完全二叉树为最小堆。</p><p><strong>最大堆的根结点中的元素在整个堆中是最大的；</strong></p><p><strong>最小堆的根结点中的元素在整个堆中是最小的。</strong></p><h2 id="哈弗曼树"><a href="#哈弗曼树" class="headerlink" title="哈弗曼树"></a>哈弗曼树</h2><ul><li><p>定义：给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。</p></li><li><p>构造：</p><p>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：</p><ol><li>将w1、w2、…，wn看成是有 n 棵树的森林(每棵树仅有一个结点)；</li><li>在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；</li><li>从森林中删除选取的两棵树，并将新树加入森林；</li><li>重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</li></ol></li></ul><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。</p><p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p><ol><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的节点</li></ol><p>二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找）</p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>平衡二叉树（balanced binary tree）,又称 AVL 树。它或者是一棵空树,或者是具有如下性质的二叉树：</p><ol><li>它的左子树和右子树都是平衡二叉树，</li><li>左子树和右子树的深度之差的绝对值不超过1。</li></ol><p>平衡二叉树是对二叉搜索树(又称为二叉排序树)的一种改进。二叉搜索树有一个缺点就是，树的结构是无法预料的，随意性很大，它只与节点的值和插入的顺序有关系，往往得到的是一个不平衡的二叉树。在最坏的情况下，可能得到的是一个单支二叉树，其高度和节点数相同，相当于一个单链表，对其正常的时间复杂度有O(log(n))变成了O(n)，从而丧失了二叉排序树的一些应该有的优点。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p><strong>B-树</strong>：B-树是一种非二叉的查找树， 除了要满足查找树的特性，还要满足以下结构特性：</p><p>一棵 m 阶的B-树：</p><ol><li>树的根或者是一片叶子(一个节点的树),或者其儿子数在 2 和 m 之间。</li><li>除根外，所有的非叶子结点的孩子数在 m/2 和 m 之间。</li><li>所有的叶子结点都在相同的深度。</li></ol><p>B-树的平均深度为logm/2(N)。执行查找的平均时间为O(logm)；</p><h2 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h2><p>Trie 树，又称前缀树，字典树， 是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p><p>Trie 树查询和插入时间复杂度都是 O(n)，是一种以空间换时间的方法。当节点树较多的时候，Trie 树占用的内存会很大。</p><p>Trie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p><h1 id="解决树问题的一般递归思路"><a href="#解决树问题的一般递归思路" class="headerlink" title="解决树问题的一般递归思路"></a>解决树问题的一般递归思路</h1><p>给定一棵树（此处以二叉树为例），要求求出某种满足条件的结果（如最大路径和）或者判断某结果是否成立（如判断是否为平衡二叉树）。<br>一般思路是：当前节点做根节点，要得到结果，<br>    1. 需要自己的左子树给自己什么。<br>    2. 需要自己的右子树给自己什么。<br>    3. 需要自己进行什么操作。<br>    4. 将自己需要的东西同理的求出来返回给自己的上级（自己的根节点）。<br>    5. 考虑边界条件，一般是节点为空时如何处理，加在函数开头做判断。<br>调用这个递归函数，把根节点作为输入，得到的结果就是最终的结果。</p><h2 id="判断二叉树是否为平衡二叉树"><a href="#判断二叉树是否为平衡二叉树" class="headerlink" title="判断二叉树是否为平衡二叉树"></a>判断二叉树是否为平衡二叉树</h2><p>lc110</p><p>思路：<br>每个节点需要直到自己左子树的深度，右子树的深度。如果这两个深度相差超过1，则不是平衡二叉树，如果没超过，则算出自己的深度（左右子深度大的+1），返回给自己的父节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsBalanceTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> balance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalance</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = helper(node.left);</span><br><span class="line">        <span class="keyword">int</span> right = helper(node.right);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(left-right)&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找到二叉树中的最大路径和"><a href="#找到二叉树中的最大路径和" class="headerlink" title="找到二叉树中的最大路径和"></a>找到二叉树中的最大路径和</h2><p>lc 124</p><p>思路：<br>对于一个节点，需要左右子树给自己以左右子为一端的最大路径和。之后更新最大路径和，最大路径和有可能是当前节点值加上左右子返回的值（如果这两个值中有负的则没有加的必要），或者之前的值。之后求出以自己为开头的最大路径和返回上一级。考虑节点为空的情况，返回0即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPathSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=Integer.MIN_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>,helper(root.left));</span><br><span class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>,helper(root.right));</span><br><span class="line">        <span class="keyword">this</span>.res = Math.max(<span class="keyword">this</span>.res,root.val+left+right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p>lc226</p><p>思路：</p><p>对于每个节点，交换自己的左右子树，之后把自己返回给自己的父节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = node;</span><br><span class="line">        helper(root.left);</span><br><span class="line">        helper(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="特殊树的性质运用"><a href="#特殊树的性质运用" class="headerlink" title="特殊树的性质运用"></a>特殊树的性质运用</h1><h2 id="搜索二叉树"><a href="#搜索二叉树" class="headerlink" title="搜索二叉树"></a>搜索二叉树</h2><p>对于搜素二叉树，中序遍历的结果会是一个有序递增序列，利用这一点通过中序遍历来找到答案，不需要一般树的思考过程。</p><h3 id="找到搜索二叉树中排错的两个点并更正"><a href="#找到搜索二叉树中排错的两个点并更正" class="headerlink" title="找到搜索二叉树中排错的两个点并更正"></a>找到搜索二叉树中排错的两个点并更正</h3><p>lc 99</p><p>思路：中序遍历二叉树，如果是正确的，后边的值一定比前边的大，反之证明前面这个值放错地方了，接着遍历，因为只有一处错误，后边一定有且仅有一个比这个错误值小的，找到后交换这两个值即可。（用三个指针分别存两个错误值和当前值的前一个）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecoveryBST</span> </span>&#123;</span><br><span class="line">    TreeNode first = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode second = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode prve = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">recovery</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">this</span>.first.val^=<span class="keyword">this</span>.second.val;</span><br><span class="line">        <span class="keyword">this</span>.second.val^=<span class="keyword">this</span>.first.val;</span><br><span class="line">        <span class="keyword">this</span>.first.val^=<span class="keyword">this</span>.second.val;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.left);</span><br><span class="line">        <span class="keyword">if</span>(prve != <span class="keyword">null</span> &amp;&amp; prve.val&gt;root.val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first ==<span class="keyword">null</span>)&#123;</span><br><span class="line">                first = prve;</span><br><span class="line">            &#125;</span><br><span class="line">            second = root;</span><br><span class="line">        &#125;</span><br><span class="line">        prve = root;</span><br><span class="line">        helper(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://hit-alibaba.github.io/interview/basic/algo/Tree.html">https://hit-alibaba.github.io/interview/basic/algo/Tree.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bit Manipulation</title>
      <link href="/2019/08/31/bit-manipulation/"/>
      <url>/2019/08/31/bit-manipulation/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>基本思路：将给定的数字都转化为二进制，然后进行相应的操作。</p><!----------------------more----------------------------><h1 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h1><p>符号&lt;&lt;</p><p>操作：将数字转换成二进制，然后左移x位，空缺补零。</p><p>效果：乘2^x</p><p>例子：</p><p>7&lt;&lt;1 =14, 7&lt;&lt;2=28…</p><p>7的二进制是111，左移后变成1110是14。</p><h1 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h1><p>符号：&gt;&gt;</p><p>操作：将数字转化成二进制，然后右移x位</p><p>效果：除2^x</p><p>例子：</p><p>7&gt;&gt;1=3, 7&gt;&gt;2=1</p><p>7的二进制是111，右移变成11。</p><h1 id="与操作"><a href="#与操作" class="headerlink" title="与操作"></a>与操作</h1><p>符号：&amp;</p><p>操作：将两数字a，b转换成二进制，如果位数不同短的前面补零，之后逐位算与，得到结果。</p><p><strong>常用：用a&amp;1判断a的奇偶。</strong></p><p>例子：</p><p>7&amp;3=3</p><p>111</p><p>&amp;</p><p>011</p><p>=011=3</p><h1 id="或操作"><a href="#或操作" class="headerlink" title="或操作"></a>或操作</h1><p>符号|</p><p>符号：&amp;</p><p>操作：将两数字a，b转换成二进制，如果位数不同短的前面补零，之后逐位算或，得到结果。</p><p>例子：</p><p>7&amp;3=7</p><p>111</p><p>|</p><p>011</p><p>=</p><p>111</p><h1 id="抑或操作"><a href="#抑或操作" class="headerlink" title="抑或操作"></a>抑或操作</h1><p>符号：^</p><p>操作：将两数字转换为二进制，长度不等短的前面补零，二者逐位比较，相同为0，不同为1</p><p>例子：</p><p>7^3=4</p><p>111</p><p>^</p><p>011</p><p>=</p><p>100=4</p><p>应用：交换两数字a，b： </p><p>a^=b </p><p>b^=a </p><p>a^=b</p><p>三部操作后a，b互换</p><p>比如：</p><p>a=101 b=11101。操作一后 a=11000 操作二后 b=101 操作三后 a = 11101。 </p><h1 id="非操作"><a href="#非操作" class="headerlink" title="非操作"></a>非操作</h1><p>符号:~</p><p>操作：将数子转换为二进制，每位取反（此时前面的0也作数，比如Java中32位表示一个整数）</p><p>例子：</p><p>～7=-8</p><p>~00000000000000000000000000000111</p><p>=</p><p>11111111111111111111111111111000</p><p>=-8</p><h1 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h1><p>符号：&gt;&gt;&gt;</p><p>操作：无视整数的正负，将其右移一位。</p><h1 id="Java-正负数的表示"><a href="#Java-正负数的表示" class="headerlink" title="Java 正负数的表示"></a>Java 正负数的表示</h1><p>Java中用32为表示一个整数，其中最高位表示的是整数的符号，0为正1为负。因此有以下几点注意：</p><ol><li><p>得到一个数的相反数就将其取反+1。比如：7=00000000000000000000000000000111，,7=11111111111111111111111111111001</p></li><li><p>对于右移操作（&gt;&gt;），考虑原来数字的正负，因此移动完毕后在前面用0或1补位（正数补0，负数补1）。而对于无符号右移操作（&gt;&gt;&gt;），不考虑符号，移动完毕后都补0。比如：</p><p>7&gt;&gt;1=3,  -7&gt;&gt;1=-3,  7&gt;&gt;&gt;1=3,   -7&gt;&gt;&gt;1=2147483644。（对正数来说都一样）。</p></li><li><p>左移操作没有无符号一说，都是在末尾补0。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack and Queue</title>
      <link href="/2019/08/03/Stack-and-Queue/"/>
      <url>/2019/08/03/Stack-and-Queue/</url>
      
        <content type="html"><![CDATA[<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>Stack，栈，一种数据结构，拥有“先进后出”的特性，简单来说就是先进入栈的元素会后出栈。类似叠放的一摞盘子，放在底部的盘子是先放进来的，但要想拿到就必须先把后放入的在它上面的盘子都拿出来。</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue，队列，另一种数据结构，拥有“先进先出”的特性，就是先进入队列的元素先出队列。类似排队，先排入队伍中的先被服务，出队列。</p><!-----------------more----------------><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="Stack-1"><a href="#Stack-1" class="headerlink" title="Stack"></a>Stack</h2><p>list 实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Stack(object):</span><br><span class="line">    def __init__(object):</span><br><span class="line">        self.stack &#x3D; []</span><br><span class="line"></span><br><span class="line">    def push(self, value):</span><br><span class="line">        self.stack.append(value)</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        if self.stack:</span><br><span class="line">            self.stack.pop()</span><br><span class="line">        else:</span><br><span class="line">            raise LookupError(&#39;stack is empty!&#39;)</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return bool(self.stack)</span><br><span class="line"></span><br><span class="line">    def top(self):</span><br><span class="line">        return self.stack[-1]</span><br></pre></td></tr></table></figure><p>链表实现：<br>用head存储栈的头尾，使操作都为O(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class Head(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.left &#x3D; None   # left存储栈底</span><br><span class="line">        self.right &#x3D; None  # right存储栈顶</span><br><span class="line"></span><br><span class="line">class Node(object):</span><br><span class="line">    def __init__(self, value):</span><br><span class="line">        self.value &#x3D; value</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Stack(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        #初始化节点</span><br><span class="line">        self.head &#x3D; Head()</span><br><span class="line"></span><br><span class="line">    def push(self, value):</span><br><span class="line">        #插入一个元素</span><br><span class="line">        newnode &#x3D; Node(value)</span><br><span class="line">        p &#x3D; self.head</span><br><span class="line">        if p.right:</span><br><span class="line">            #如果head节点的右边不为NOne</span><br><span class="line">            #说明栈中已经有元素了</span><br><span class="line">            #就执行下列的操作</span><br><span class="line">            temp &#x3D; p.right</span><br><span class="line">            p.right &#x3D; newnode</span><br><span class="line">            newnode.next &#x3D; temp  #队列和栈的区别，一个链表正接，一个链表反接</span><br><span class="line">        else:</span><br><span class="line">            #这说明队列为空，插入第一个元素</span><br><span class="line">            p.right &#x3D; newnode</span><br><span class="line">            p.left &#x3D; newnode</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        #取出一个元素</span><br><span class="line">        p &#x3D; self.head</span><br><span class="line">        if p.left and (p.left &#x3D;&#x3D; p.right):</span><br><span class="line">            #说明栈中已经有元素</span><br><span class="line">            #但是这是最后一个元素</span><br><span class="line">            temp &#x3D; p.left</span><br><span class="line">            p.left &#x3D; p.right &#x3D; None</span><br><span class="line">            return temp.value</span><br><span class="line">        elif p.left and (p.left !&#x3D; p.right):</span><br><span class="line">            #说明栈中有元素，而且不止一个</span><br><span class="line">            temp &#x3D; p.right</span><br><span class="line">            p.right &#x3D; temp.next</span><br><span class="line">            return temp.value</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            #说明栈为空</span><br><span class="line">            #抛出查询错误</span><br><span class="line">            raise LookupError(&#39;queue is empty!&#39;)</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        if self.head.left:</span><br><span class="line">            return False</span><br><span class="line">        else:</span><br><span class="line">            return True</span><br><span class="line"></span><br><span class="line">    def bottom(self):</span><br><span class="line">        #查询目前栈中栈底元素</span><br><span class="line">        if self.head.left:</span><br><span class="line">            return self.head.left.value</span><br><span class="line">        else:</span><br><span class="line">            raise LookupError(&#39;queue is empty!&#39;)</span><br></pre></td></tr></table></figure><h2 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h2><p>list实现：入队列加入队尾，出队列从头部拿取元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Queue(object):</span><br><span class="line">    def __init__(object):</span><br><span class="line">        self.stack &#x3D; []</span><br><span class="line"></span><br><span class="line">    def enqueue(self, value):</span><br><span class="line">        self.stack.append(value)</span><br><span class="line"></span><br><span class="line">    def dequeue(self):</span><br><span class="line">        if self.stack:</span><br><span class="line">            self.stack.pop(0)</span><br><span class="line">        else:</span><br><span class="line">            raise LookupError(&#39;stack is empty!&#39;)</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return bool(self.stack)</span><br><span class="line"></span><br><span class="line">    def top(self):</span><br><span class="line">        return self.queue[0]</span><br></pre></td></tr></table></figure><p>链表实现:<br>定义一个头结点，左边指向队列的开头，右边指向队列的末尾，这样就可以保证我们插入一个元素和取出一个元素都是O(1)的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class Head(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line">class Node(object):</span><br><span class="line">    def __init__(self, value):</span><br><span class="line">        self.value &#x3D; value</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Queue(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        #初始化节点</span><br><span class="line">        self.head &#x3D; Head()</span><br><span class="line"></span><br><span class="line">    def enqueue(self, value):</span><br><span class="line">        #插入一个元素</span><br><span class="line">        newnode &#x3D; Node(value)</span><br><span class="line">        p &#x3D; self.head</span><br><span class="line">        if p.right:</span><br><span class="line">            #如果head节点的右边不为NOne</span><br><span class="line">            #说明队列中已经有元素了</span><br><span class="line">            #就执行下列的操作</span><br><span class="line">            temp &#x3D; p.right</span><br><span class="line">            p.right &#x3D; newnode</span><br><span class="line">            temp.next &#x3D; newnode</span><br><span class="line">        else:</span><br><span class="line">            #这说明队列为空，插入第一个元素</span><br><span class="line">            p.right &#x3D; newnode</span><br><span class="line">            p.left &#x3D; newnode</span><br><span class="line"></span><br><span class="line">    def dequeue(self):</span><br><span class="line">        #取出一个元素</span><br><span class="line">        p &#x3D; self.head</span><br><span class="line">        if p.left and (p.left &#x3D;&#x3D; p.right):</span><br><span class="line">            #说明队列中已经有元素</span><br><span class="line">            #但是这是最后一个元素</span><br><span class="line">            temp &#x3D; p.left</span><br><span class="line">            p.left &#x3D; p.right &#x3D; None</span><br><span class="line">            return temp.value</span><br><span class="line">        elif p.left and (p.left !&#x3D; p.right):</span><br><span class="line">            #说明队列中有元素，而且不止一个</span><br><span class="line">            temp &#x3D; p.left</span><br><span class="line">            p.left &#x3D; temp.next</span><br><span class="line">            return temp.value</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            #说明队列为空</span><br><span class="line">            #抛出查询错误</span><br><span class="line">            raise LookupError(&#39;queue is empty!&#39;)</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        if self.head.left:</span><br><span class="line">            return False</span><br><span class="line">        else:</span><br><span class="line">            return True</span><br><span class="line"></span><br><span class="line">    def top(self):</span><br><span class="line">        #查询目前队列中最早入队的元素</span><br><span class="line">        if self.head.left:</span><br><span class="line">            return self.head.left.value</span><br><span class="line">        else:</span><br><span class="line">            raise LookupError(&#39;queue is empty!&#39;)</span><br></pre></td></tr></table></figure><h1 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h1><h2 id="Stack-2"><a href="#Stack-2" class="headerlink" title="Stack"></a>Stack</h2><p>查看括号的完整性：<br>给定由前后括号组成的字符串，判断这个括号串是否合法。<br>思路：遍历字符串，如果是左括号则入栈，右括号则出栈一个，如果最后栈为空，则合法。</p><h2 id="Queue-2"><a href="#Queue-2" class="headerlink" title="Queue"></a>Queue</h2><p>窗口内最大最小值的更新结构：</p><p>给定一个数组，和一个更新窗口，大小为k，当窗口从头到尾滑动时，不断更新窗口内的最大最小值。</p><p>思路：</p><p>利用双端队列来解决这个问题，双端队列，两端都可以出队，但只有队尾可以入队，java中由双向链表实现。</p><p><strong>窗口内最大值和最小值的更新结构：双端队列（双向链表），查询窗口内的最大或最小值为O(1)操作。将窗口元素从大到小排列的位置加入这个双端队列。</strong></p><p><strong>加入逻辑：新元素试图从尾部进，如果值小于当前尾部，则将其位置加入双端队列，否则从尾部弹出元素（相等也弹出），直到该元素可以从尾部加入）。</strong></p><p><strong>退出逻辑：当一个元素弹出窗口时，看这个数的位置是否是双端队列的头，如果是，就从头弹出。</strong></p><p><strong>该队列永远保证头是当前窗口内最大值的位置，如果要保存最小值，再建立一个递增序排列的双端队列。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Backtracking</title>
      <link href="/2019/08/01/Backtracking/"/>
      <url>/2019/08/01/Backtracking/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>Backtracking，回溯算法，一般用于枚举类问题，比如给定x，要求找到关于x的满足条件y所有可能结果z。这样的问题都可以用回溯算法来解。总体思路为深度遍历x，先看第一层可以选择x内的哪个元素，定下来后再进行递归调用，在x剩下元素中挑选加入后仍旧满足y的，定下后再次递归调用。当到达一层后满足输出条件则在结果z中加入当前组合然后退出，或者当到达一层后发现无法再继续向下（到达了x底端或者之后的所有可能都不会满足条件y）时退回上一层，并且要把这层加入的元素退出。一般回溯算法可以分为两类，第一类是要求找到满足条件的集合，称为子集树，解没有顺序要求。第二类是找到满足条件的排列，称为排列树，解是有顺序要求的。<br>典型题目有：排列组合，N皇后，01背包问题等。</p><!-------------more-------------------><h1 id="排列树"><a href="#排列树" class="headerlink" title="排列树"></a>排列树</h1><p>排列树，就是指初始元素集x里的相对顺序重要，比如x=[1,2,3,4] 求出x的所有排列。此时[1,2,3,4]和[2,1,3,4]是两个不同的解，都需要加入结果中。因此不用顺序遍历记录index递归的方法，使用等长数组记录visited的方法来做。比如下文的排列例子。<br>一般写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def backtracking(s,visited,curr,res):</span><br><span class="line">if curr satisfied output condition:</span><br><span class="line">res.add(curr)</span><br><span class="line">return</span><br><span class="line">for i in range(len(s)):</span><br><span class="line">if s[i] not visited:</span><br><span class="line">        visited[i] &#x3D; True</span><br><span class="line">        curr.add(s[i])</span><br><span class="line">        if curr satisfied condition y:</span><br><span class="line">        backtracking(s,visited,curr,res)</span><br><span class="line">        visited[i] &#x3D; False</span><br><span class="line">        curr.pop()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种写法（只返回长度为n的排列）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def backtracking(t):</span><br><span class="line">if t&#x3D;&#x3D;n:</span><br><span class="line">output(x)</span><br><span class="line">return</span><br><span class="line">for i in range(t,n):</span><br><span class="line">swap(x[t],x[i])</span><br><span class="line">if constraint(t):</span><br><span class="line">backtracking(t+1)</span><br><span class="line">swap[x[t],x[i]]</span><br></pre></td></tr></table></figure><p>排列数的时间复杂度为O(n!)</p><h1 id="子集树"><a href="#子集树" class="headerlink" title="子集树"></a>子集树</h1><p>所谓子集树，就是指元素间的相对顺序不重要，比如组合，x=[1,2,3,4]，此时[1,2,3,4] 和[2,1,3,4] 完全一样，只需返回一个即可。此时用顺序遍历记录index递归即可，不需要记录visited。即当走到某个元素时，该元素之前的元素都不需要被访问了。问题的解的长度不是固定的，即可以从中选择0个或多个。比如下文的组合例子，N皇后例子，01背包例子。<br>一般写法（不回头遍历的思路）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def backtracking(s,index,curr,res):</span><br><span class="line">if curr satisfied output condition:</span><br><span class="line">res.add(curr)</span><br><span class="line">return</span><br><span class="line">for i in range(index,len(s)):</span><br><span class="line">curr.add(s[i])</span><br><span class="line">if curr satisfied condition y:</span><br><span class="line">backtracking(i+1,curr,res)</span><br><span class="line">curr.pop()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另一种对这类问题的理解是每次对原集合中的一个元素做判断，是加入还是不加入（有的问题状态会多于两个比如n皇后）分别做二叉树的两支继续往下讨论，当走不动了就剪枝。</p><p>另一种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def backtracking(t):</span><br><span class="line">if t&#x3D;&#x3D;n:</span><br><span class="line">output(x)</span><br><span class="line">return</span><br><span class="line">for i in range(2): &#x2F;&#x2F;i有两个取值0，1表示选或者不选 x[t]，灵活看待，对于n皇后则i有n个取值</span><br><span class="line">x[t]&#x3D;i</span><br><span class="line">if constraint(t):</span><br><span class="line">backtracking(t+1)</span><br></pre></td></tr></table></figure><p>子集树的时间复杂度是O(2^n)</p><h1 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h1><p>问题描述：<br>给定一个N*N的棋盘，要求放入N个皇后，要满足这N个皇后任意两个不同行，不同列，不同对角线，求出一共有几种放置方法。<br>由于N个棋子之间没有差异，因此这是个不回头的回溯问题，套用上方一般写法，加入判断条件即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def queen(index,N,curr,res):</span><br><span class="line">if index &#x3D;&#x3D; N:</span><br><span class="line">res[0]+&#x3D;1</span><br><span class="line">return</span><br><span class="line">for i in range(N):</span><br><span class="line">curr[index] &#x3D; i</span><br><span class="line">if valided(index):</span><br><span class="line">queen(index+1,N,curr,res)</span><br><span class="line">def valid(index):</span><br><span class="line">k&#x3D;0</span><br><span class="line">while k&lt;index:</span><br><span class="line">if curr[k]&#x3D;&#x3D;curr[index]:</span><br><span class="line">return False</span><br><span class="line">if abs(curr[k]-curr[index])&#x3D;&#x3D;i-k:</span><br><span class="line">return False</span><br><span class="line">return True</span><br><span class="line"></span><br><span class="line">def nQueens(N):</span><br><span class="line">    res &#x3D; [0]</span><br><span class="line">    curr &#x3D; [0]*N</span><br><span class="line">    queen(0,N,curr,res)</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure><h1 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h1><p>问题描述：<br>给定一个列表或字符串或数列，求出其中元素可能组成的不同排列。<br>分两种情况，如果有重复元素，则可以用集合来存储结果达到去重的目的，如果没有，则直接用列表存储就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def permutation(s,visited,curr,res):</span><br><span class="line">if curr not in res and curr !&#x3D;&quot;&quot;:</span><br><span class="line">res.add(curr)</span><br><span class="line">for i in range(len(s)):</span><br><span class="line">if not visited[i]:</span><br><span class="line">visited[i] &#x3D; True</span><br><span class="line">curr+&#x3D;s[i]</span><br><span class="line">permutation(s,viisted,curr,res)</span><br><span class="line">visited[i] &#x3D; False</span><br><span class="line">curr &#x3D; curr[:-1]</span><br><span class="line">def use(s):</span><br><span class="line">visited &#x3D; [False]*len(s)</span><br><span class="line">curr &#x3D; &quot;&quot;</span><br><span class="line">res &#x3D; set()</span><br><span class="line">permutation(s,visited,curr,res)</span><br><span class="line">return res</span><br></pre></td></tr></table></figure><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>问题描述：<br>给定一个列表或字符串或数列，要求从中取出k个元素组成集合，问可以组成多少种不同组合。<br>同理，如果有重复元素则用集合来保存结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def combination(s,index,k,curr,res):</span><br><span class="line">if len(curr) &#x3D;&#x3D; k and curr not in res:</span><br><span class="line">res.add(curr)</span><br><span class="line">return</span><br><span class="line">for i in range(index,len(s)):</span><br><span class="line">curr+&#x3D;s[i]</span><br><span class="line">combination(s,i+1,k,curr,res)</span><br><span class="line">cur &#x3D; cur[:-1]</span><br><span class="line">def use(s,k):</span><br><span class="line">res &#x3D; set()</span><br><span class="line">combination(s,0,k,&quot;&quot;,res)</span><br><span class="line">return len(res)</span><br></pre></td></tr></table></figure><h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><p>问题描述：</p><p>有一堆价值和重量不等的商品，一个小偷想偷走它们，但是他的背包只能承受W的重量，求如何拿商品使得收益最大。</p><p>利用子集树求解0-1背包问题，主要还是如何剪枝。即，在什么情况下会选择不搜索左子树（放弃x_i=1），在什么情况下会选择不搜索右子树（放弃x_i=0）。</p><p>当选择x_i=1，背包就会超重时，就会放弃搜索左子树；当选择x_i=0，当前背包的价值和剩余未放入物品（不包括物品i，因为已经选择不放）的价值总和都小于目前最佳价值时，说明已经预测到这个没有前景了，可以放弃继续搜索右子树了。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局变量W：背包承重，cw：当前背包内的重量，cv：当前价值，w：各个物品重量，v：各个物品价格，m：求得的最大值，n：物品个数,x：表示每件物品状态。</span><br><span class="line">def bound(i): &#x2F;&#x2F;预估一个放入当前物品后能达到的价值上界</span><br><span class="line">rw &#x3D; W-cw  &#x2F;&#x2F; 剩余容量</span><br><span class="line">vb &#x3D; cv  &#x2F;&#x2F; 当前背包价值初始化为上一层算出的背包价值</span><br><span class="line">&#x2F;&#x2F; 按单位价值递减放入物品</span><br><span class="line">while i&lt;n and w[i] &lt;&#x3D;rw:</span><br><span class="line">rw -&#x3D; w[i]</span><br><span class="line">vb +&#x3D; v[i]</span><br><span class="line">i+&#x3D;1</span><br><span class="line">if i&lt;n:</span><br><span class="line">vb+&#x3D;(v[i]&#x2F;w[i])*wr </span><br><span class="line">&#x2F;&#x2F; 如果当前不是回溯的最后一层即还没有对最后一个商品进行过判断，计算出一个之后价值的上限vb（由于物品按单位重量价值排序，后面的单位重量一定不会超过当前的，所以后面的价值一定不会超过把剩余重量全部换算为当前物品）</span><br><span class="line">return vb</span><br><span class="line">def backtracking(i):</span><br><span class="line">if i&#x3D;&#x3D;n:</span><br><span class="line">m &#x3D; max(cv,m)</span><br><span class="line">return</span><br><span class="line">if cw+w[i]&lt;&#x3D;W: &#x2F;&#x2F;左子树，放入第i个物品</span><br><span class="line">x[i]&#x3D;1</span><br><span class="line">cw+&#x3D;w[i]</span><br><span class="line">cv+&#x3D;v[i]</span><br><span class="line">backtracking(i+1)</span><br><span class="line">x[i]&#x3D;0</span><br><span class="line">cw-&#x3D;w[i]</span><br><span class="line">cv-&#x3D;v[i]</span><br><span class="line">if bound(i+1)&gt;m &#x2F;&#x2F; 右子树， 即拿出第i个后面的值仍可能超过当前的最大值m</span><br><span class="line">backtracking(i+1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>01背包是子集树问题，因此时间复杂度为O(2^n),空间复杂度为O(n)。此问题还可以动态规划来解，详见动态规划笔记。</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frp内网穿透+jupyter Notebook 远程连接</title>
      <link href="/2019/07/23/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F+jupyter-notebook%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
      <url>/2019/07/23/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F+jupyter-notebook%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章记录了如何利用frp实现内网穿透从而远程访问Linux主机，本文介绍如何在此基础上远程连接jupyter notebook</p><!-----------------------more------------------------><h1 id="更改frp的设置"><a href="#更改frp的设置" class="headerlink" title="更改frp的设置"></a>更改frp的设置</h1><h2 id="更改外网服务器设置"><a href="#更改外网服务器设置" class="headerlink" title="更改外网服务器设置"></a>更改外网服务器设置</h2><p>登入外网服务器，打开frps.ini如下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port &#x3D; 7000</span><br><span class="line">vhost_http_port &#x3D; 8888（加上这一行）</span><br></pre></td></tr></table></figure><p>保存重启</p><h2 id="更改内网服务器设置"><a href="#更改内网服务器设置" class="headerlink" title="更改内网服务器设置"></a>更改内网服务器设置</h2><p>打开frpc.ini，加上如下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 这个是对于穿透jupyter配置</span><br><span class="line">[jupyter]</span><br><span class="line">type &#x3D; http</span><br><span class="line">local_port &#x3D; 8888</span><br><span class="line">custom_domains &#x3D; 公网服务器ip</span><br></pre></td></tr></table></figure><p>保存重启</p><h1 id="更改jupyter-notebook-设置"><a href="#更改jupyter-notebook-设置" class="headerlink" title="更改jupyter notebook 设置"></a>更改jupyter notebook 设置</h1><p>设置密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>打开生成的 jupyter_notebook_config.json，在.jupyter下，复制生成密码的hash结果<br>打开jupyter_notebook_config.py，取消注释并更改以下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.ip&#x3D;&#39;0.0.0.0&#39;</span><br><span class="line">c.NotebookApp.password &#x3D; u&#39;刚才复制的那个密文&#39;</span><br><span class="line">c.NotebookApp.open_browser &#x3D; False</span><br><span class="line">c.NotebookApp.port &#x3D;8888</span><br></pre></td></tr></table></figure><p>在内网服务器打开jupyter，或者远程ssh连接后打开jupyter。<br>在远程电脑打卡浏览器，输入“外网服务器ip：8888” 即可打开jupyter。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>远程访问jupyter notebook：<a href="https://blog.csdn.net/kunlong0909/article/details/52464495">https://blog.csdn.net/kunlong0909/article/details/52464495</a><br>jupyter notebook + frp 实现内容穿透：<a href="https://blog.csdn.net/martind/article/details/82716445">https://blog.csdn.net/martind/article/details/82716445</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Frp实现非局域网远程连接</title>
      <link href="/2019/07/21/%E5%88%A9%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E9%9D%9E%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
      <url>/2019/07/21/%E5%88%A9%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E9%9D%9E%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍如何解决不同局域网下两台电脑远程连接的问题。对于windows平台来说，直接用Google的远程桌面即可，体验不错。但对于Linux系统，Google目前的支持很差，还是回归ssh连接的老套路，但是直接使用ssh连接只能用于同一局域网下，为了实现外网的访问，利用frp来解决。</p><!----------------------more---------------------><h1 id="ubuntu安装ssh服务端"><a href="#ubuntu安装ssh服务端" class="headerlink" title="ubuntu安装ssh服务端"></a>ubuntu安装ssh服务端</h1><p>首先在要作为服务器的ubuntu主机上安装ssh服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>然后确认sshserver是否启动了：（或用“netstat -tlp”命令）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e|grep ssh</span><br></pre></td></tr></table></figure><p>如果只有ssh-agent那ssh-server还没有启动，需要/etc/init.d/ssh start，如果看到sshd那说明ssh-server已经启动了。 </p><p>如果没有则可以这样启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo&#x2F;etc&#x2F;init.d&#x2F;ssh start</span><br></pre></td></tr></table></figure><h1 id="frp所需要的材料"><a href="#frp所需要的材料" class="headerlink" title="frp所需要的材料"></a>frp所需要的材料</h1><p>一个有公网ip的服务器做转发用，此处称之为外网服务器。<br>可以去vultr <a href="https://my.vultr.com/#">https://my.vultr.com/#</a> 购买，便宜好用，还可以用于shadowsocks 翻墙。<br>一个要当作服务器被远程访问的内网电脑，此处称之为内网服务器。</p><h1 id="外网服务器设置"><a href="#外网服务器设置" class="headerlink" title="外网服务器设置"></a>外网服务器设置</h1><p>此处外网服务器时centsOS系统<br>下载frp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.27.0&#x2F;frp_0.27.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解压：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zxf frp_0.27.0_linux_amd64.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改配置（如果只作为ssh用则不需要修改）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入文件</span><br><span class="line">cd frp_0.27.0_linux_amd64&#x2F;</span><br><span class="line"># 修改配置</span><br><span class="line">vi frps.ini </span><br></pre></td></tr></table></figure><p>默认配置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port &#x3D; 7000</span><br></pre></td></tr></table></figure><p>关闭防火墙（如果不做，内网服务器启动frp时会报no route to host 错误）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><p>启动服务，后台运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup .&#x2F;frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure><h1 id="内网服务器设置"><a href="#内网服务器设置" class="headerlink" title="内网服务器设置"></a>内网服务器设置</h1><p>下载frp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.27.0&#x2F;frp_0.27.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解压：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxf frp_0.27.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>修改我们的客户端配置文件frpc.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入文件</span><br><span class="line">cd frp_0.27.0_linux_amd64&#x2F;</span><br><span class="line"># 修改配置</span><br><span class="line">vi frpc.ini</span><br></pre></td></tr></table></figure><p>可以看到客户端默认配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; 120.79.17.158</span><br><span class="line">server_port &#x3D; 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type &#x3D; tcp</span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 22</span><br><span class="line">remote_port &#x3D; 6000</span><br></pre></td></tr></table></figure><p>[common]表示以下配置信息是一些公用配置信息<br>server_addr是我们服务端即外网服务器的公网访问ip<br>server_port是我们前面在服务端配置的frps.ini中bind_port中对应的端口。需保持两边一致<br>[ssh]表示以下配置信息是我们使用ssh连接内网服务器时需要的一些配置信息<br>type 是连接类型，ssh方式连接就用tcp<br>local_ip 是本机ip,直接使用127.0.0.1即可<br>local_port 是本地ssh端口，ssh默认端口为22<br>remote_port 是外网服务器请求过来的端口 </p><p>启动服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup .&#x2F;frpc -c frpc.ini &amp;</span><br></pre></td></tr></table></figure><p>看到start proxy success 则成功</p><h1 id="尝试远程连接"><a href="#尝试远程连接" class="headerlink" title="尝试远程连接"></a>尝试远程连接</h1><p>用另一台电脑尝试连接内网服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh x.x.x.x(外网服务器ip) -p 6000（上面设定的remote_port）</span><br></pre></td></tr></table></figure><p>密码就是ubuntu登录用户的密码。连接成功即可远程操作家里的Ubuntu主机啦。</p><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p>Ubuntu环境下SSH的安装及使用：<a href="https://blog.csdn.net/netwalk/article/details/12952051">https://blog.csdn.net/netwalk/article/details/12952051</a><br>CentOS下搭建Frp内网穿透服务： <a href="https://blog.csdn.net/kxwinxp/article/details/88428053">https://blog.csdn.net/kxwinxp/article/details/88428053</a><br>十分钟快速搭建frp的ssh和http的内网穿透： <a href="https://blog.csdn.net/u012198893/article/details/82348605">https://blog.csdn.net/u012198893/article/details/82348605</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人机器学习平台搭建2</title>
      <link href="/2019/07/20/%E4%B8%AA%E4%BA%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA2/"/>
      <url>/2019/07/20/%E4%B8%AA%E4%BA%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录Ubuntu系统下机器学习相关环境的安装和配置</p><!-------------------more------------------><h1 id="安装-CUDA"><a href="#安装-CUDA" class="headerlink" title="安装 CUDA"></a>安装 CUDA</h1><p>首先在这个网站查看tensorflow，cuda，python的版本对应关系，选择合适的版本。<br><a href="https://www.tensorflow.org/install/source#tested_source_configurations">https://www.tensorflow.org/install/source#tested_source_configurations</a><br>本机安装cuda10.0，python版本为3.6，对应tensorflow版本为1.14.0<br>确定后到cuda官网<a href="https://developer.nvidia.com/cuda-10.0-download-archive">https://developer.nvidia.com/cuda-10.0-download-archive</a><br>下载cuda10.0的对应run文件，还有一个补丁文件，同样下载。</p><img src="/2019/07/20/%E4%B8%AA%E4%BA%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA2/cuda.JPG" class="" title="个人机器学习平台搭建2"><p>之后将下载好的文件解压，进入到对应目录后用这个命令运行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh cuda_10.0.130_410.48_linux.run</span><br></pre></td></tr></table></figure><p>注意，运行后有很长的协议要看，回车慢慢向下翻就好。有一步问是否安装显卡驱动，由于之前已经装过，一定选否。<br>对补丁文件同样方法运行即可。</p><p>安装完成后添加环境变量，<br>打开：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit .bashrc</span><br></pre></td></tr></table></figure><p>添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export CUDA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda </span><br><span class="line">export PATH&#x3D;$PATH:$CUDA_HOME&#x2F;bin </span><br><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda-10.0&#x2F;lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br></pre></td></tr></table></figure><p>保存并退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><p>安装推荐的第三方库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++ freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libglu1-mesa libglu1-mesa-dev</span><br></pre></td></tr></table></figure><p>测试安装是否成功，运行一个cuda的例子：<br>进入example下make,此命令会准备所有例子，大概需要10分钟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;samples</span><br><span class="line">sudo make</span><br></pre></td></tr></table></figure><p>之后进入一个例子运行下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;samples&#x2F;1_Utilities&#x2F;deviceQuery </span><br><span class="line">sudo .&#x2F;deviceQuery</span><br></pre></td></tr></table></figure><p>如果输出result=pass 说明成功。</p><h1 id="安装-CUDNN"><a href="#安装-CUDNN" class="headerlink" title="安装 CUDNN"></a>安装 CUDNN</h1><p>在官网下载cuda10.0对应的版本，选择library for Linux，解压文件，将其中的内容复制到CUDA安装文件夹里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo cp cuda&#x2F;include&#x2F;cudnn.h &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;include&#x2F; </span><br><span class="line">sudo cp cuda&#x2F;lib64&#x2F;libcudnn* &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64&#x2F; -d </span><br><span class="line">sudo chmod a+r &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;include&#x2F;cudnn.h </span><br><span class="line">sudo chmod a+r &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64&#x2F;libcudnn*</span><br></pre></td></tr></table></figure><p>测试是否成功，查看版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;include&#x2F;cudnn.h | grep CUDNN_MAJOR -A 2</span><br></pre></td></tr></table></figure><p>如果出现版本信息则成功。</p><h1 id="安装-Anaconda3"><a href="#安装-Anaconda3" class="headerlink" title="安装 Anaconda3"></a>安装 Anaconda3</h1><p>到官网下载<br><a href="https://www.anaconda.com/distribution/#download-section">https://www.anaconda.com/distribution/#download-section</a><br>到下载的目录下运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash Anaconda3-5.1.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>查看是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure><h1 id="安装-TensorFlow"><a href="#安装-TensorFlow" class="headerlink" title="安装 TensorFlow"></a>安装 TensorFlow</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tensorflow pip python&#x3D;3.6       &#x2F;&#x2F;创建python3.6对应的Tensorflow环境</span><br><span class="line">source activate tensorflow                      &#x2F;&#x2F;激活tensorflow</span><br><span class="line">pip install tensorflow                          &#x2F;&#x2F;安装tensorflow</span><br></pre></td></tr></table></figure><p>测试是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source activate tensorflow  &#x2F;&#x2F; 切换到tensorflow环境而非base</span><br><span class="line">pyhton3 &#x2F;&#x2F; 激活pyhton3</span><br><span class="line">import tensorflow as tf &#x2F;&#x2F;运行这句不报错即可</span><br><span class="line">source deactivate &#x2F;&#x2F; 用于取消激活tensorflow环境(这个环境名是自己取的，叫tf更好)</span><br></pre></td></tr></table></figure><h1 id="安装-Jupyter-Notebook"><a href="#安装-Jupyter-Notebook" class="headerlink" title="安装 Jupyter Notebook"></a>安装 Jupyter Notebook</h1><p>在需要的conda环境下，安装，不要直接用python3 安装，否则对应环境下仍没有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure><p>之后用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>开启<br>一般操作流程为先用anaconda激活tensorflow环境，再打开jupyter notebook， 这样就可以再notebook里用tf了。<br>设定notebook的默认工作路径：<br>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p>在~/home 或者c盘usrs administrators  下找到文件夹  .jupyter 修改jupyter_application_config.py 文件。<br>找到下面这句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\# The directory to use for notebooks.</span><br></pre></td></tr></table></figure><p>按下面的格式，输入你想要的目录路径即可 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.notebook_dir &#x3D; &#39;path&#x2F;to&#x2F;your&#x2F;notebooks&#39;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人机器学习平台搭建1</title>
      <link href="/2019/05/26/%E4%B8%AA%E4%BA%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA1/"/>
      <url>/2019/05/26/%E4%B8%AA%E4%BA%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章中记录个人机器学习平台的搭建过程，包括硬件选择，组装，系统安装，相关环境的搭建过程。</p><!--------------more----------------><h1 id="硬件选择"><a href="#硬件选择" class="headerlink" title="硬件选择"></a>硬件选择</h1><p>本平台配置如下：</p><table><thead><tr><th>配件</th><th>型号</th></tr></thead><tbody><tr><td>处理器</td><td>Intel Core i9-9900k</td></tr><tr><td>显卡</td><td>MSI TRIO RTX 2080TI</td></tr><tr><td>电源</td><td>CORSAIR RM850x</td></tr><tr><td>固态硬盘</td><td>SAMSUNG 970 EVO PLUS 500GB</td></tr><tr><td>水冷</td><td>Corsair Hydro Series, H150i PRO</td></tr><tr><td>内存</td><td>CORSAIR Vengeance RGB Pro64GB(4x16)</td></tr><tr><td>机械硬盘</td><td>WD Blue 4TB Desktop</td></tr><tr><td>主板</td><td>ASUS ROG Strix Z390-E Gaming</td></tr><tr><td>机箱</td><td>DEEPCOOL MATREXX 55</td></tr><tr><td>风扇</td><td>DEEPCOOL RF120</td></tr><tr><td>总价：$3,300</td><td></td></tr></tbody></table><img src="/2019/05/26/%E4%B8%AA%E4%BA%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA1/components.jpg" class="" title="个人机器学习平台搭建1"><h1 id="组装"><a href="#组装" class="headerlink" title="组装"></a>组装</h1><p>第一次组装电脑，其实很简单，主要记录几个要点以后注意可以提高效率。</p><ol><li>这个机箱的硬盘仓会妨碍水冷安装风扇，最终不得不把风扇安装在机箱前侧的外面，下次选购机箱注意硬盘仓位置，或者直接购买顶部支持360冷排的机箱。</li><li>按照以下顺序安装可以防止返工：<ol><li>安装主板上的零件cpu，内存，固态硬盘</li><li>安装风扇和冷排到机箱上</li><li>安装主板进机箱</li><li>涂抹硅脂</li><li>安装冷头到cpu</li><li>连接机箱线到主板</li><li>安装硬盘并与主板连接</li><li>连接风扇，冷头线到主板</li><li>安装显卡</li><li>连接电源线和电源</li><li>安装电源进机箱</li><li>连接电源线和主板，显卡，硬盘，冷头的stata供电。</li><li>理线</li><li>亮机</li><li>安装机箱侧板</li><li>连接主板的wifi模块</li></ol></li><li>显卡的拆卸注意，先按下卡扣再拔出，内存同理</li><li>有些风扇是3pin口，也可以连接到4pin上</li></ol><p>装机完毕，上张图：</p><img src="/2019/05/26/%E4%B8%AA%E4%BA%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA1/computer.jpg" class="" title="个人机器学习平台搭建1"><h1 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h1><p>起初准备安装windows和Linux双系统，最后考虑到机器用途和双系统的不稳定，浪费存储等原因，决定只安装Linux。<br>最终选择 Ubuntu 18.04.2 LTS 做为系统，安装步骤如下：</p><ol><li><p>前往<a href="https://www.ubuntu.com/download/desktop">ubuntu 官方网站</a> 下载系统</p></li><li><p>插入一个空的U盘</p></li><li><p>用<a href="https://www.ultraiso.com/download.html">UltraISO</a>打开下载好的iso，制作系统盘</p></li><li><p>将制作好的系统盘插入新电脑，在bios里设置U盘启动。高端主板可以不设置，没有系统时会自动检测U盘启动。</p></li><li><p>进入Ubuntu安装界面，关键的几步选择如下：</p><ol><li><p>在这里选择第一项就是单系统，若要安装双系统建议先装win，之后装Ubuntu，千万不能选第一个，否则win就没了</p><img src="/2019/05/26/%E4%B8%AA%E4%BA%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA1/install-ubuntu-18-04-lts-5.jpg" class="" title="个人机器学习平台搭建1"></li><li><p>可以选其他选项来自己分硬盘，但不推荐，用于装系统的固态硬盘用系统默认分配即可，存储数据的机械硬盘如果大小超过2T，在这里是不能分区的，可以安装完系统再分，之后会有详细教程。</p></li><li><p>其他内容根据提示按自己的情况选择即可。</p></li></ol></li></ol><h1 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h1><p>系统安装成功后会非常卡顿，这是因为没有安装显卡驱动，系统用的还是cpu来进行显示。安装显卡驱动步骤如下:</p><ol><li><p>系统自带的显卡驱动不是NVIDIA的，先删除这个驱动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge nvidia*</span><br></pre></td></tr></table></figure></li><li><p>添加Graphic Drivers PPA</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers&#x2F;ppa</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>查找驱动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu-drivers devices</span><br></pre></td></tr></table></figure></li><li><p>选择推荐的驱动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nvidia-driver-415</span><br></pre></td></tr></table></figure></li><li><p>之后重启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>重启后点开系统Setting里面的Detail,就可以看到系统识别到了2080Ti了</p><h1 id="磁盘分区和挂载"><a href="#磁盘分区和挂载" class="headerlink" title="磁盘分区和挂载"></a>磁盘分区和挂载</h1><p>由于本机采用的机械硬盘大小为4T，超过了2T，无法用fdisk格式化为ext4格式。因此采用parted来进行分区操作。<br>分区步骤：</p></li><li><p>查看现在硬盘的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure></li><li><p>选中要分区的硬盘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parted &#x2F;dev&#x2F;sdc(&#x2F;dev&#x2F;sdc是自己的硬盘名，对应上一步查出的结果)</span><br></pre></td></tr></table></figure></li><li><p>在parted中，建立GPT分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mklabel gpt</span><br></pre></td></tr></table></figure></li><li><p>分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkpart p1(p1是分区名字，叫啥都行)</span><br></pre></td></tr></table></figure></li><li><p>按提示，start表示起始位，输入你想要的值，end为截止，同理。可以用百分比，K，M，G，T来表示 </p></li><li><p>按提示确定即可</p></li><li><p>格式化分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext3 &#x2F;dev&#x2F;sda2(分区名字)</span><br></pre></td></tr></table></figure></li><li><p>创建想要挂载的文件夹，推荐挂载在home下，比如/home/code，在home下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;code</span><br></pre></td></tr></table></figure></li><li><p>挂载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;sda2 &#x2F;code </span><br></pre></td></tr></table></figure></li><li><p>设置自动挂载，打卡文件/etc/fstab在最后加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dev&#x2F;sda2 (要挂载的盘)  &#x2F;data（挂载在该文件夹下） ext3(格式)  defaults 0 0</span><br></pre></td></tr></table></figure></li></ol><p>注意：<br>此处坑比较多，自动挂载必须先手动挂载过一次才行，即第九步不能省略，否则有可能因为无法挂载硬盘进入Ubuntu紧急模式，如果这样，不要慌，查看下log，看清楚原因，注释掉fstab里的内容，重启后再试一次。<br>另外，貌似不能挂载在用户下。</p><h1 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h1><p>此处选择搜狗输入法。</p><ol><li>上网选择搜狗输入法linux版，下载对应的deb包，双击安装。</li><li>确定系统里有fcitx应用</li><li>卸载系统自带的输入法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove &#39;ibus*&#39;</span><br></pre></td></tr></table></figure></li><li>进入语言设置，根据红色箭头进入语言安装界面，安装语言（会自动安装中文语言），根据下方箭头更爱输入框架为fcitx，然后点击上面的Apply System-Wide应用到全局。然后将当前用户进行注销后再进行登录（注销没有效果，重启就可以了）。<img src="/2019/05/26/%E4%B8%AA%E4%BA%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA1/language.jpg" class="" title="个人机器学习平台搭建1"><img src="/2019/05/26/%E4%B8%AA%E4%BA%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA1/language2.jpg" class="" title="个人机器学习平台搭建1"></li></ol><ol start="5"><li>登陆后在右上角出现一个键盘标志，点击进入，选择Configure Current Input Method<img src="/2019/05/26/%E4%B8%AA%E4%BA%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA1/language3.jpg" class="" title="个人机器学习平台搭建1"></li><li>点击加号，添加sogou即可<img src="/2019/05/26/%E4%B8%AA%E4%BA%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA1/language4.jpg" class="" title="个人机器学习平台搭建1"></li><li>空格加shift来切换</li></ol><p>下一篇介绍机器学习相关软件的安装包括cuda，cuNN，python，Anaconda3，TensorFlow</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li><a href="https://www.sysgeek.cn/install-ubuntu-18-04-lts/">如何安装Ubuntu 18.04 LTS桌面和服务器版，详细步骤</a></li><li><a href="https://blog.csdn.net/u012318074/article/details/74551405">ubuntu 使用 fdisk 磁盘分区</a></li><li><a href="https://zhuanlan.zhihu.com/p/51373519">Ubuntu18+RTX2080Ti从0开始搭建深度学习环境TensorFlow+PyTorch</a></li><li><a href="https://blog.csdn.net/zhengchaooo/article/details/79500075">Ubuntu挂载3T硬盘或大于2T磁盘</a></li><li><a href="https://www.cnblogs.com/the-tops/p/8110546.html">分区工具parted的详解及常用分区使用方法</a></li><li><a href="https://blog.csdn.net/lupengCSDN/article/details/80279177">Ubuntu18.04下安装搜狗输入法</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Equipment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sort Algorithms II</title>
      <link href="/2019/05/16/Sort-algorithms-II/"/>
      <url>/2019/05/16/Sort-algorithms-II/</url>
      
        <content type="html"><![CDATA[<h1 id="Sort-algorithms-II"><a href="#Sort-algorithms-II" class="headerlink" title="Sort algorithms II"></a>Sort algorithms II</h1><p>In this article, I listed some specific usages of sort algorithms such as merge linked list, iterative quick sort.</p><!------------------------more--------------------------><h2 id="Merge-linked-list"><a href="#Merge-linked-list" class="headerlink" title="Merge linked list"></a>Merge linked list</h2><h3 id="Single-linked-list"><a href="#Single-linked-list" class="headerlink" title="Single linked list"></a>Single linked list</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_init__</span>(<span class="params">self,value</span>):</span></span><br><span class="line">self.value = value</span><br><span class="line">self.next = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortedMerge</span>(<span class="params">node1,node2</span>):</span></span><br><span class="line"><span class="keyword">if</span> node1==<span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span> node2</span><br><span class="line"><span class="keyword">if</span> node2 == <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span> node1</span><br><span class="line"><span class="keyword">if</span> node1.val&lt;=node2.val:</span><br><span class="line">res = node1</span><br><span class="line">res.next = sortedMerge(node1.next,node2)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res = node2</span><br><span class="line">res.next = sortedMerge(node1,node2.next)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMiddle</span>(<span class="params">head</span>):</span></span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">fastptr = head.next</span><br><span class="line">slowptr = head</span><br><span class="line"><span class="comment"># fast moves two nodes each time</span></span><br><span class="line"><span class="comment"># slow only moves one node</span></span><br><span class="line"><span class="comment"># when fast reaches the end+1</span></span><br><span class="line"><span class="comment"># slow just moves half</span></span><br><span class="line"><span class="keyword">while</span> fastptr != <span class="literal">None</span>:</span><br><span class="line">fastptr = fastptr.next</span><br><span class="line"><span class="keyword">if</span> fastptr !=<span class="literal">None</span>:</span><br><span class="line">slowptr = slowptr.next</span><br><span class="line">fastptr = fastptr.next</span><br><span class="line"><span class="keyword">return</span> slowptr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">head</span>):</span></span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">None</span> || head.next ==<span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">mid = getMiddle(head)</span><br><span class="line">midNext = mid.next</span><br><span class="line">mid.next = <span class="literal">None</span></span><br><span class="line">left = mergeSort(head)</span><br><span class="line">right = mergeSort(midNext)</span><br><span class="line">sortedlist = sortedMerge(left,right)</span><br><span class="line"><span class="keyword">return</span> sortedlist</span><br></pre></td></tr></table></figure><h3 id="Double-linked-list"><a href="#Double-linked-list" class="headerlink" title="Double linked list"></a>Double linked list</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,value</span>):</span></span><br><span class="line">self.value = value</span><br><span class="line">self.next = <span class="literal">None</span></span><br><span class="line">self.prev = <span class="literal">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">first,second</span>):</span></span><br><span class="line"><span class="keyword">if</span> first <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span> second</span><br><span class="line"><span class="keyword">if</span> second <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span> first</span><br><span class="line"><span class="keyword">if</span> first.value &lt; second.value:</span><br><span class="line">first.next = merge(first.next,second)</span><br><span class="line">first.next.prev = first</span><br><span class="line">first.prev = <span class="literal">None</span></span><br><span class="line"><span class="keyword">return</span> first</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">second.next = merge(first,second.next)</span><br><span class="line">second.next.prev = second</span><br><span class="line">second.prev = <span class="literal">None</span></span><br><span class="line"><span class="keyword">return</span> second</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span>(<span class="params">temphead</span>):</span></span><br><span class="line">fast = slow = temphead</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">if</span> fast.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> fast.next.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">fast = fast.next.next</span><br><span class="line">slow = slow.next</span><br><span class="line">temp = slow.next</span><br><span class="line">slow.next = <span class="literal">None</span></span><br><span class="line"><span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">temphead</span>):</span></span><br><span class="line"><span class="keyword">if</span> temphead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span> temphead</span><br><span class="line"><span class="keyword">if</span> temphead.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span> temphead</span><br><span class="line">second = split(temphead)</span><br><span class="line">temphead = mergeSort(temphead)</span><br><span class="line">second = mergeSort(second)</span><br><span class="line"><span class="keyword">return</span> merge(temphead,second)</span><br></pre></td></tr></table></figure><h2 id="Iterative-quick-sort"><a href="#Iterative-quick-sort" class="headerlink" title="Iterative quick sort"></a>Iterative quick sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find the partition place of an array</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">array,low,high</span>):</span></span><br><span class="line"><span class="comment">#take the last value as pivot</span></span><br><span class="line">pivot = array[high]</span><br><span class="line"><span class="comment"># index before the first one</span></span><br><span class="line"><span class="comment"># start comparing with the first one</span></span><br><span class="line">i = low<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(low,high):</span><br><span class="line"><span class="keyword">if</span> array[j]&lt;pivot:</span><br><span class="line">i+=<span class="number">1</span></span><br><span class="line">temp = array[i]</span><br><span class="line">array[i] = array[j]</span><br><span class="line">array[j] = temp</span><br><span class="line"><span class="comment">#put pivot back to right place</span></span><br><span class="line">temp = array[i+<span class="number">1</span>]</span><br><span class="line">array[i+<span class="number">1</span>] = array[high]</span><br><span class="line">array[high] = temp</span><br><span class="line"><span class="comment"># if there is no move, return low</span></span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSortIterative</span>(<span class="params">array,l,h</span>):</span></span><br><span class="line">stack = []</span><br><span class="line">stack.append(l)</span><br><span class="line">stack.append(h)</span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">h = stack.pop(<span class="number">-1</span>)</span><br><span class="line">l = stack.pop(<span class="number">-1</span>)</span><br><span class="line">p = partition(array,l,h)</span><br><span class="line"><span class="keyword">if</span> p<span class="number">-1</span>&gt;l:</span><br><span class="line">stack.append(l)</span><br><span class="line">stack.append(p<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> p+<span class="number">1</span>&lt;h:</span><br><span class="line">stack.append(p+<span class="number">1</span>)</span><br><span class="line">stack.append(h)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New Start</title>
      <link href="/2019/05/15/New-Start/"/>
      <url>/2019/05/15/New-Start/</url>
      
        <content type="html"><![CDATA[<h1 id="Don’t-panic-keep-coding"><a href="#Don’t-panic-keep-coding" class="headerlink" title="Don’t panic, keep coding"></a>Don’t panic, keep coding</h1>]]></content>
      
      
      
        <tags>
            
            <tag> talk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sort Algorithms</title>
      <link href="/2019/05/14/Sort-algorithms/"/>
      <url>/2019/05/14/Sort-algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="Sort-algorithms"><a href="#Sort-algorithms" class="headerlink" title="Sort algorithms"></a>Sort algorithms</h1><p>In this article, I listed some common sort algorithms and the python code to implement them. I also listed the time and space complexity of each algorithms.</p><!-----------------------more---------------------><h1 id="Sort-algorithms-1"><a href="#Sort-algorithms-1" class="headerlink" title="Sort algorithms"></a>Sort algorithms</h1><h2 id="Selection-sort"><a href="#Selection-sort" class="headerlink" title="Selection sort"></a>Selection sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionsort</span>(<span class="params">array</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">min_idx = i</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(array)):</span><br><span class="line"><span class="keyword">if</span> array[j]&lt; array[min_idx]:</span><br><span class="line">min_idx = j</span><br><span class="line">array[min_idx],array[i] = array[i], array[min_idx]</span><br><span class="line"><span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><p>time complexity O(n^2)<br>space complexity O(1)  </p><h2 id="Bubble-sort"><a href="#Bubble-sort" class="headerlink" title="Bubble sort"></a>Bubble sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubblesort</span>(<span class="params">array</span>):</span></span><br><span class="line">n = len(array)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,n-i<span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> array[j]&gt;array[j+<span class="number">1</span>]:</span><br><span class="line">array[j],array[j+<span class="number">1</span>] = array[j+<span class="number">1</span>], array[j]</span><br><span class="line"><span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><p>time complexity O(n^2)<br>space complexity O(1)  </p><h2 id="Insert-sort"><a href="#Insert-sort" class="headerlink" title="Insert sort"></a>Insert sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertsort</span>(<span class="params">array</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(array)):</span><br><span class="line">key = array[i]</span><br><span class="line">j = i<span class="number">-1</span></span><br><span class="line"><span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> key &lt; array[j]:</span><br><span class="line">array[j+<span class="number">1</span>] = array[j]</span><br><span class="line">j-=<span class="number">1</span></span><br><span class="line">array[j+<span class="number">1</span>] = key</span><br><span class="line"><span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><p>time complexity O(n^2)<br>space complexity O(1)  </p><h2 id="Shell-sort"><a href="#Shell-sort" class="headerlink" title="Shell sort"></a>Shell sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">array</span>):</span></span><br><span class="line">gap = int(len(array)/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">while</span> gap&gt;<span class="number">0</span>:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)-gap):</span><br><span class="line"><span class="keyword">if</span> array[i]&gt;array[i+gap]:</span><br><span class="line">array[i],array[i+gap]=array[i+gap],array[i]</span><br><span class="line">gap = int(gap/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><p>time complexity O(n^2)<br>space complexity O(1)</p><h2 id="Merge-sort"><a href="#Merge-sort" class="headerlink" title="Merge sort"></a>Merge sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergesort</span>(<span class="params">array</span>):</span></span><br><span class="line"><span class="keyword">if</span> len(array)&gt;<span class="number">1</span>:</span><br><span class="line">mid = len(array)//<span class="number">2</span></span><br><span class="line">L = array[:mid]</span><br><span class="line">R = array[mid:]</span><br><span class="line">mergesort(L)</span><br><span class="line">mergesort(R)</span><br><span class="line"><span class="comment">#merge L and R</span></span><br><span class="line">i=j=k=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;len(L) <span class="keyword">and</span> j&lt;len(R):</span><br><span class="line"><span class="keyword">if</span> L[i]&lt;R[j]:</span><br><span class="line">array[k] = L[i]</span><br><span class="line">i+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">array[k] = R[j]</span><br><span class="line">j+=<span class="number">1</span></span><br><span class="line">k+=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i&lt;len(L):</span><br><span class="line">array[k] = L[i]</span><br><span class="line">i+=<span class="number">1</span></span><br><span class="line">k+=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &lt; len(R):</span><br><span class="line">array[k] = R[j]</span><br><span class="line">j+=<span class="number">1</span></span><br><span class="line">k+=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span>(<span class="params">array</span>):</span></span><br><span class="line">mergesort(array)</span><br><span class="line"><span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><p>time complexity O(nlogn)<br>space complexity O(n)  </p><h2 id="Heap-sort"><a href="#Heap-sort" class="headerlink" title="Heap sort"></a>Heap sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span>(<span class="params">array</span>):</span></span><br><span class="line">n = len(array)</span><br><span class="line"><span class="comment">#build a maxheap</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">heapify(array,n,i)</span><br><span class="line"><span class="comment"># extract elements one by one</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">array[i],array[<span class="number">0</span>] = array[<span class="number">0</span>],array[i]</span><br><span class="line">heapify(array,i,<span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span>(<span class="params">array,n,i</span>):</span></span><br><span class="line">largest = i</span><br><span class="line">l = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">r = <span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> l&lt;n <span class="keyword">and</span> array[i]&lt;array[l]:</span><br><span class="line">largest = l</span><br><span class="line"><span class="keyword">if</span> r&lt;n <span class="keyword">and</span> array[i]&lt;array[r]:</span><br><span class="line">largest = r</span><br><span class="line"><span class="keyword">if</span> largest != i:</span><br><span class="line">array[i],array[largest] = array[largest],array[i]</span><br><span class="line">heapify(array,n,largest)</span><br></pre></td></tr></table></figure><p>for more details about <a href="./Data-structure/Heap.md">Heap</a><br>time complexity O(nlogn)<br>space complexity O(logn)  </p><h2 id="Quick-sort"><a href="#Quick-sort" class="headerlink" title="Quick sort"></a>Quick sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params">array,l,r</span>):</span></span><br><span class="line"><span class="keyword">if</span> l&lt;r:</span><br><span class="line">i,j,x = l,r,array[l]</span><br><span class="line"><span class="keyword">while</span> i&lt;j:</span><br><span class="line"><span class="keyword">while</span> i&lt;j <span class="keyword">and</span> array[j]&gt;=x:</span><br><span class="line">j-=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i&lt;j:</span><br><span class="line">array[i] = array[j]</span><br><span class="line">i+=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i&lt;j <span class="keyword">and</span> array[i]&lt;=x:</span><br><span class="line">i+=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i&lt;j:</span><br><span class="line">array[j] = array[i]</span><br><span class="line">j-=<span class="number">1</span></span><br><span class="line">array[i] = x</span><br><span class="line">quicksort(array,l,i<span class="number">-1</span>)</span><br><span class="line">quicksort(array,i+<span class="number">1</span>,r)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">QuickSort</span>(<span class="params">array</span>):</span></span><br><span class="line">quicksort(array,<span class="number">0</span>,len(array)<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> array</span><br><span class="line">````</span><br><span class="line">time complexity O(nlogn)  </span><br><span class="line">space complexity O(logn)  </span><br><span class="line"><span class="comment">## Counting sort</span></span><br><span class="line">```python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countsort</span>(<span class="params">array</span>):</span></span><br><span class="line">n = len(array)</span><br><span class="line">output = [<span class="number">0</span>]*(n)</span><br><span class="line">count = [<span class="number">0</span>]*(k) <span class="comment"># numbers in array are from 0 to k</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">index = aray[i]</span><br><span class="line">count[index] +=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">count[i]+=count(i<span class="number">-1</span>)</span><br><span class="line">i = n<span class="number">-1</span></span><br><span class="line"><span class="keyword">while</span> i&gt;=<span class="number">0</span>:</span><br><span class="line">index = array[i]</span><br><span class="line">output[count[index]<span class="number">-1</span>] = array[i]</span><br><span class="line">count[index]-=<span class="number">1</span></span><br><span class="line">i-=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">array[i] = output[i]</span><br><span class="line"><span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><p>time complexity O(n+k)<br>space complexity O(n)  </p><h2 id="Radix-sort"><a href="#Radix-sort" class="headerlink" title="Radix sort"></a>Radix sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radixsort</span>(<span class="params">array</span>):</span></span><br><span class="line">max_val = max(array)</span><br><span class="line">exp =<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> max1/exp&gt;<span class="number">0</span>:</span><br><span class="line">countsortbit(array,exp)</span><br><span class="line">exp*=<span class="number">10</span></span><br><span class="line"><span class="keyword">return</span> array</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countsortbit</span>(<span class="params">array,exp</span>):</span></span><br><span class="line">n = len(array)</span><br><span class="line">output = [<span class="number">0</span>]*(n)</span><br><span class="line">count = [<span class="number">0</span>]*(n)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">index = array[i]/exp1</span><br><span class="line">count[index%<span class="number">10</span>]+=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">count[i]+=count[i<span class="number">-1</span>]</span><br><span class="line">i=n<span class="number">-1</span></span><br><span class="line"><span class="keyword">while</span> i&gt;=<span class="number">0</span>:</span><br><span class="line">index = array[i]/exp</span><br><span class="line">output[count[index%<span class="number">10</span>]<span class="number">-1</span>] = array[i]</span><br><span class="line">count[index%<span class="number">10</span>]-=<span class="number">1</span></span><br><span class="line">i-=<span class="number">1</span></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">array[i] = output[i]</span><br></pre></td></tr></table></figure><p>time complexity O((n+b)*logb(k)) (k is the max number, b is the decimal system)<br>space complexity O(n)  </p><h2 id="bucket-sort"><a href="#bucket-sort" class="headerlink" title="bucket sort"></a>bucket sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># used for uniformly distributed values over a range. </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucketsort</span>(<span class="params">array</span>):</span></span><br><span class="line">arr = []</span><br><span class="line">slot_num = <span class="number">10</span> <span class="comment"># divide the range into 10 slots</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(slot_num):</span><br><span class="line">arr.append([])</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> array:</span><br><span class="line">index = int(slot_num*j)</span><br><span class="line">arr[index].append(j)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(slot_num):</span><br><span class="line">arr[i] = insertionSort(arr[i])</span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(slot_num):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr[i])):</span><br><span class="line">array[k] = arr[i][j]</span><br><span class="line">k+=<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><p>time complexity O(n)<br>space complexity O(n)  </p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Search Algorithms</title>
      <link href="/2019/05/13/Search-algorithms/"/>
      <url>/2019/05/13/Search-algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="Search-algorithms"><a href="#Search-algorithms" class="headerlink" title="Search algorithms"></a>Search algorithms</h1><p>In this article, I listed some common search algorithms and the python code to implement them. I also listed the time and space complexity of each algorithms.</p><!-----------------more----------------><h2 id="Linear-search"><a href="#Linear-search" class="headerlink" title="Linear search"></a>Linear search</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linearsearch</span>(<span class="params">array,key</span>):</span></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;len(array) <span class="keyword">and</span> array[i] != key:</span><br><span class="line">i+=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> array[i] == key:</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>time complexity O(n)<br>space complexity O(1)  </p><h2 id="Binary-search"><a href="#Binary-search" class="headerlink" title="Binary search"></a>Binary search</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarysearch</span>(<span class="params">array, key</span>):</span></span><br><span class="line">left =<span class="number">0</span></span><br><span class="line">right = len(array)<span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> left &gt;= right:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">while</span> left &lt;= right:</span><br><span class="line">mid = int((right+left)/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> array[mid] == key:</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line"><span class="keyword">elif</span> array[mid]&lt;key:</span><br><span class="line">left = mid+<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">right = mid<span class="number">-1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>time complexity O(logn)<br>space complexity O(1)  </p><h2 id="Jump-search"><a href="#Jump-search" class="headerlink" title="Jump search"></a>Jump search</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jumpsearch</span>(<span class="params">array,key</span>):</span></span><br><span class="line">n = len(array)</span><br><span class="line">step = math.sqrt(n)</span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> array[int(min(step,n)<span class="number">-1</span>)]&lt;key:</span><br><span class="line">prev = step</span><br><span class="line">step += math.sqrt(n)</span><br><span class="line"><span class="comment"># key is larger than the last number in array</span></span><br><span class="line"><span class="keyword">if</span> prev &gt; n:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="comment"># got the range from prev to step</span></span><br><span class="line"><span class="comment"># check one by one</span></span><br><span class="line"><span class="keyword">while</span> array[int(prev)] &lt; key:</span><br><span class="line">prev+=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> prev==min(step,n):</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="comment"># found the true one</span></span><br><span class="line"><span class="keyword">if</span> array[int(prev)] == key:</span><br><span class="line"><span class="keyword">return</span> int(prev)</span><br><span class="line"><span class="comment"># no one fits, index of prev larger than key</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>time complexity O(n^0.5)<br>space complexity O(1)  </p><h2 id="Interpolation-Search"><a href="#Interpolation-Search" class="headerlink" title="Interpolation Search"></a>Interpolation Search</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">interpolationsearch</span>(<span class="params">array,key</span>):</span></span><br><span class="line">n = len(array)</span><br><span class="line">left =<span class="number">0</span></span><br><span class="line">right = n<span class="number">-1</span></span><br><span class="line"><span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> key&gt;=array[left] <span class="keyword">and</span> key&lt;=array[right]:</span><br><span class="line"><span class="keyword">if</span> left == right:</span><br><span class="line"><span class="keyword">if</span> array[left] == key:</span><br><span class="line"><span class="keyword">return</span> left</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="comment"># different from binary search, pos is not the middle one</span></span><br><span class="line">pos = left + int(((float(right-left)/(array[right]-array[left]))*(key-array[left])))</span><br><span class="line"><span class="keyword">if</span> array[pos] == key:</span><br><span class="line"><span class="keyword">return</span> pos</span><br><span class="line"><span class="keyword">elif</span> array[pos] &lt; key:</span><br><span class="line">left =pos +<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">right=pos<span class="number">-1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>time complexity O(loglogn)<br>space complexity O(1)  </p><h2 id="Exponential-search"><a href="#Exponential-search" class="headerlink" title="Exponential search"></a>Exponential search</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#binary search in recursive way</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarysearch</span>(<span class="params">array,left,right,key</span>):</span></span><br><span class="line"><span class="keyword">if</span> right&gt;=left:</span><br><span class="line">mid = left + int((right-left))/<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> array[mid]==key</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line"><span class="keyword">elif</span> array[mid]&gt;key:</span><br><span class="line"><span class="keyword">return</span> binarysearch(array,left,mid<span class="number">-1</span>,key)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> binarysearch(array,mid+<span class="number">1</span>,right,key)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exponentialsearch</span>(<span class="params">array,key</span>):</span></span><br><span class="line">n = len(array)</span><br><span class="line"><span class="keyword">if</span> array[<span class="number">0</span>]==key:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i&lt;n <span class="keyword">and</span> array[i]&lt;key:</span><br><span class="line">i = i*<span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> binarysearch(array,int(i/<span class="number">2</span>),min(i,n),key)</span><br></pre></td></tr></table></figure><p>time complexity O(logn)<br>space complexity O(1)  </p><h2 id="Ternary-Search"><a href="#Ternary-Search" class="headerlink" title="Ternary Search"></a>Ternary Search</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ternarysearch</span>(<span class="params">array, left, right, key</span>):</span></span><br><span class="line"><span class="keyword">if</span> right&gt;=left:</span><br><span class="line">mid1 = left + int((right-left)/<span class="number">3</span>)</span><br><span class="line">mid2 = left + int(<span class="number">2</span>*(right-left)/<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> array[mid1]==key:</span><br><span class="line"><span class="keyword">return</span> mid1</span><br><span class="line"><span class="keyword">if</span> array[mid2]==key:</span><br><span class="line"><span class="keyword">return</span> mid2</span><br><span class="line"><span class="keyword">if</span> array[mid1]&gt;key:</span><br><span class="line"><span class="keyword">return</span> ternarysearch(array,left,mid1<span class="number">-1</span>,key)</span><br><span class="line"><span class="keyword">if</span> array[mid2]&lt;key:</span><br><span class="line"><span class="keyword">return</span> ternarysearch(array,mid2+<span class="number">1</span>,right,key)</span><br><span class="line"><span class="keyword">return</span> ternarysearch(array,mid1+<span class="number">1</span>,mid2<span class="number">-1</span>,key)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>time complexity O(2log3n)<br>space complexity O(1)<br><strong>note:</strong> It is not better than binary search.<br><strong>All algorithms need a sorted array except the linear search.</strong>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Analysis of Algorithms</title>
      <link href="/2019/05/12/Analysis-of-algorithms/"/>
      <url>/2019/05/12/Analysis-of-algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="Three-cases"><a href="#Three-cases" class="headerlink" title="Three cases"></a>Three cases</h1><ol><li>worst case</li><li>average case</li><li>best case</li></ol><h2 id="Worst-cases"><a href="#Worst-cases" class="headerlink" title="Worst cases"></a>Worst cases</h2><p>In the worst case, we calculate the upper bound on running time. For example, for the algorithms to sort an array, the worst case is that the array is in reverse order.<br>The worst case analysis is usually done since if you can accept the worst case performance of an algorithm, you can accept its performance on every case. </p><h2 id="Average-cases"><a href="#Average-cases" class="headerlink" title="Average cases"></a>Average cases</h2><p>In the average case, we calculate the average running time of all possible cases.<br>Sometimes, we will use the average case analysis.</p><h2 id="Best-cases"><a href="#Best-cases" class="headerlink" title="Best cases"></a>Best cases</h2><p>In the best case, we calculate the lower bound on running time. It is useless since most of the time, the input case cannot be the best one. Although the best case performance of an algorithm could be good, it still cannot work well on most of the cases.</p><!-----------------------more-------------------><h1 id="time-complexity"><a href="#time-complexity" class="headerlink" title="time complexity"></a>time complexity</h1><h2 id="Θ-Notation"><a href="#Θ-Notation" class="headerlink" title="Θ Notation"></a>Θ Notation</h2><p>The theta notation bounds a functions from above and below, so it defines exact asymptotic behavior.<br>For a given function g(n), we denote Θ(g(n)) is following set of functions.</p><p>Θ(g(n)) = {f(n): there exist positive constants c1, c2 and n0 such<br>                 that 0 &lt;= c1*g(n) &lt;= f(n) &lt;= c2*g(n) for all n &gt;= n0}</p><h2 id="Big-O-Notation"><a href="#Big-O-Notation" class="headerlink" title="Big O Notation"></a>Big O Notation</h2><p>The Big O notation defines an upper bound of an algorithm, it bounds a function only from above.<br>O(g(n)) = { f(n): there exist positive constants c and  n0 such that 0 &lt;= f(n) &lt;= c*g(n) for all n &gt;= n0}</p><h2 id="Ω-Notation"><a href="#Ω-Notation" class="headerlink" title="Ω Notation"></a>Ω Notation</h2><p>Ω notation provides an asymptotic lower bound.<br>Ω (g(n)) = {f(n): there exist positive constants c and n0 such that 0 &lt;= c*g(n) &lt;= f(n) for all n &gt;= n0}.</p><h2 id="Little-ο-asymptotic-notation"><a href="#Little-ο-asymptotic-notation" class="headerlink" title="Little ο asymptotic notation"></a>Little ο asymptotic notation</h2><p>Big-Ο is used as a tight upper-bound on the growth of an algorithm’s effort.  “Little-ο” (ο()) notation is used to describe the loose upper-bound.</p><p><strong>Definition</strong>  : Let f(n) and g(n) be functions that map positive integers to positive real numbers. We say that f(n) is ο(g(n)) (or f(n) Ε ο(g(n))) if for any real constant c &gt; 0, there exists an integer constant n0 ≥ 1 such that 0 ≤ f(n) &lt; c*g(n).</p><h2 id="Little-ω-asymptotic-notation"><a href="#Little-ω-asymptotic-notation" class="headerlink" title="Little ω asymptotic notation"></a>Little ω asymptotic notation</h2><p><strong>Definition</strong> : Let f(n) and g(n) be functions that map positive integers to positive real numbers. We say that f(n) is ω(g(n)) (or f(n) ∈ ω(g(n))) if for any real constant c &gt; 0, there exists an integer constant n0 ≥ 1 such that f(n) &gt; c * g(n) ≥ 0 for every integer n ≥ n0.</p><h1 id="Lower-bound-theory"><a href="#Lower-bound-theory" class="headerlink" title="Lower bound theory"></a>Lower bound theory</h1><p>According to the lower bound theory, for a lower bound L(n) of an algorithm, it is not possible to have any other algorithm (for a common problem) whose time complexity is less than L(n) for random input. Also every algorithm must take at least L(n) time in worst case. Note that L(n) here is the minimum of all the possible algorithm, of maximum complexity.</p><p>The Lower Bound is a very important for any algorithm. Once we calculated it, then we can compare it with the actual complexity of the algorithm and if their order are same then we can declare our algorithm as optimal. </p><p>our main motive is to get an optimal algorithm, which is the one having its Upper Bound Same as its Lower Bound (U(n)=L(n)). Merge Sort is a common example of an optimal algorithm.</p><p><strong>There is a lower bound for a common problem, if the time complexity or the upper bound of one algorithm is equal to this lower bound, then this algorithm is optimal.</strong></p><h1 id="Analysis-of-Loop"><a href="#Analysis-of-Loop" class="headerlink" title="Analysis of Loop"></a>Analysis of Loop</h1><h2 id="O-Logn"><a href="#O-Logn" class="headerlink" title="O(Logn)"></a>O(Logn)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i *= c) &#123;</span><br><span class="line">       <span class="comment">// some O(1) expressions</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i /= c) &#123;</span><br><span class="line">       <span class="comment">// some O(1) expressions</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="O-LogLogn"><a href="#O-LogLogn" class="headerlink" title="O(LogLogn)"></a>O(LogLogn)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Here c is a constant greater than 1   </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n; i = pow(i, c)) &#123; </span><br><span class="line">      <span class="comment">// some O(1) expressions</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Here fun is sqrt or cuberoot or any other constant root</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i = fun(i)) &#123; </span><br><span class="line">      <span class="comment">// some O(1) expressions</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="Analysis-of-Recurences"><a href="#Analysis-of-Recurences" class="headerlink" title="Analysis of Recurences"></a>Analysis of Recurences</h1><p>There are three methods to calculate the time complexity of recurences.</p><p><strong>1) Substitution Method:</strong> We make a guess for the solution and then we use mathematical induction to prove the guess is correct or incorrect.</p><p>For example consider the recurrence T(n) = 2T(n/2) + n</p><p>We guess the solution as T(n) = O(nLogn). Now we use induction<br>to prove our guess.</p><p>We need to prove that T(n) &lt;= cnLogn. We can assume that it is true<br>for values smaller than n.</p><p>T(n) = 2T(n/2) + n<br>    &lt;= cn/2Log(n/2) + n<br>    =  cnLogn - cnLog2 + n<br>    =  cnLogn - cn + n<br>    &lt;= cnLogn</p><p><strong>2) Recurrence Tree Method:</strong> In this method, we draw a recurrence tree and calculate the time taken by every level of tree. Finally, we sum the work done at all levels. To draw the recurrence tree, we start from the given recurrence and keep drawing till we find a pattern among levels. The pattern is typically a arithmetic or geometric series.</p><p>For example consider the recurrence relation<br>T(n) = T(n/4) + T(n/2) + cn2</p><pre><code>       cn2     /      \ T(n/4)     T(n/2)</code></pre><p>If we further break down the expression T(n/4) and T(n/2),<br>we get following recursion tree.</p><pre><code>            cn2       /           \         c(n2)/16      c(n2)/4  /      \          /     \</code></pre><p>  T(n/16)     T(n/8)  T(n/8)    T(n/4)<br>Breaking down further gives us following<br>                 cn2<br>            /            \<br>       c(n2)/16          c(n2)/4<br>       /      \            /      <br>c(n2)/256   c(n2)/64  c(n2)/64    c(n2)/16<br> /    \      /    \    /    \       /    \  </p><p>To know the value of T(n), we need to calculate sum of tree<br>nodes level by level. If we sum the above tree level by level,<br>we get the following series<br>T(n)  = c(n^2 + 5(n^2)/16 + 25(n^2)/256) + ….<br>The above series is geometrical progression with ratio 5/16.</p><p>To get an upper bound, we can sum the infinite series.<br>We get the sum as (n2)/(1 - 5/16) which is O(n2)<br><strong>3) Master Method:</strong><br>Master Method is a direct way to get the solution. The master method works only for following type of recurrences or for recurrences that can be transformed to following type.</p><p>T(n) = aT(n/b) + f(n) where a &gt;= 1 and b &gt; 1<br>There are following three cases:</p><ol><li><p>If f(n) = Θ(nc) where c &lt; Logba then T(n) = Θ(nLogba)</p></li><li><p>If f(n) = Θ(nc) where c = Logba then T(n) = Θ(ncLog n)</p></li></ol><p>3.If f(n) = Θ(nc) where c &gt; Logba then T(n) = Θ(f(n))</p><p>How does this work?<br>Master method is mainly derived from recurrence tree method. If we draw recurrence tree of T(n) = aT(n/b) + f(n), we can see that the work done at root is f(n) and work done at all leaves is Θ(nc) where c is Logba. And the height of recurrence tree is Logbn<br>Master Theorem<br>In recurrence tree method, we calculate total work done. If the work done at leaves is polynomially more, then leaves are the dominant part, and our result becomes the work done at leaves (Case 1). If work done at leaves and root is asymptotically same, then our result becomes height multiplied by work done at any level (Case 2). If work done at root is asymptotically more, then our result becomes work done at root (Case 3).</p><p>Examples of some standard algorithms whose time complexity can be evaluated using Master Method<br>Merge Sort: T(n) = 2T(n/2) + Θ(n). It falls in case 2 as c is 1 and Logba] is also 1. So the solution is Θ(n Logn)</p><p>Binary Search: T(n) = T(n/2) + Θ(1). It also falls in case 2 as c is 0 and Logba is also 0. So the solution is Θ(Logn)</p><h1 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h1><p><a href="https://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/">https://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
