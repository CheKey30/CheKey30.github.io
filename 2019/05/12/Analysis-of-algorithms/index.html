<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Analysis of Algorithms"><meta name="keywords" content="algorithm"><meta name="author" content="Shuchen"><meta name="copyright" content="Shuchen"><title>Analysis of Algorithms | Shuchen's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.1.0'
} </script><meta name="generator" content="Hexo 5.1.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Three-cases"><span class="toc-number">1.</span> <span class="toc-text">Three cases</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Worst-cases"><span class="toc-number">1.1.</span> <span class="toc-text">Worst cases</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Average-cases"><span class="toc-number">1.2.</span> <span class="toc-text">Average cases</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Best-cases"><span class="toc-number">1.3.</span> <span class="toc-text">Best cases</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#time-complexity"><span class="toc-number">2.</span> <span class="toc-text">time complexity</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%CE%98-Notation"><span class="toc-number">2.1.</span> <span class="toc-text">Θ Notation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Big-O-Notation"><span class="toc-number">2.2.</span> <span class="toc-text">Big O Notation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%CE%A9-Notation"><span class="toc-number">2.3.</span> <span class="toc-text">Ω Notation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Little-%CE%BF-asymptotic-notation"><span class="toc-number">2.4.</span> <span class="toc-text">Little ο asymptotic notation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Little-%CF%89-asymptotic-notation"><span class="toc-number">2.5.</span> <span class="toc-text">Little ω asymptotic notation</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lower-bound-theory"><span class="toc-number">3.</span> <span class="toc-text">Lower bound theory</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Analysis-of-Loop"><span class="toc-number">4.</span> <span class="toc-text">Analysis of Loop</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#O-Logn"><span class="toc-number">4.1.</span> <span class="toc-text">O(Logn)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#O-LogLogn"><span class="toc-number">4.2.</span> <span class="toc-text">O(LogLogn)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Analysis-of-Recurences"><span class="toc-number">5.</span> <span class="toc-text">Analysis of Recurences</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#References"><span class="toc-number">6.</span> <span class="toc-text">References:</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://user-images.githubusercontent.com/17078557/90973781-bc29e880-e557-11ea-82b9-e56107fe66b2.jpg"></div><div class="author-info__name text-center">Shuchen</div><div class="author-info__description text-center">The place to share tech and life</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/CheKey30">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">20</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://user-images.githubusercontent.com/17078557/90973809-0dd27300-e558-11ea-83d2-4431d8c12060.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Shuchen's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Analysis of Algorithms</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-12</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Three-cases"><a href="#Three-cases" class="headerlink" title="Three cases"></a>Three cases</h1><ol>
<li>worst case</li>
<li>average case</li>
<li>best case</li>
</ol>
<h2 id="Worst-cases"><a href="#Worst-cases" class="headerlink" title="Worst cases"></a>Worst cases</h2><p>In the worst case, we calculate the upper bound on running time. For example, for the algorithms to sort an array, the worst case is that the array is in reverse order.<br>The worst case analysis is usually done since if you can accept the worst case performance of an algorithm, you can accept its performance on every case. </p>
<h2 id="Average-cases"><a href="#Average-cases" class="headerlink" title="Average cases"></a>Average cases</h2><p>In the average case, we calculate the average running time of all possible cases.<br>Sometimes, we will use the average case analysis.</p>
<h2 id="Best-cases"><a href="#Best-cases" class="headerlink" title="Best cases"></a>Best cases</h2><p>In the best case, we calculate the lower bound on running time. It is useless since most of the time, the input case cannot be the best one. Although the best case performance of an algorithm could be good, it still cannot work well on most of the cases.</p>
<!-----------------------more------------------->

<h1 id="time-complexity"><a href="#time-complexity" class="headerlink" title="time complexity"></a>time complexity</h1><h2 id="Θ-Notation"><a href="#Θ-Notation" class="headerlink" title="Θ Notation"></a>Θ Notation</h2><p>The theta notation bounds a functions from above and below, so it defines exact asymptotic behavior.<br>For a given function g(n), we denote Θ(g(n)) is following set of functions.</p>
<p>Θ(g(n)) = {f(n): there exist positive constants c1, c2 and n0 such<br>                 that 0 &lt;= c1*g(n) &lt;= f(n) &lt;= c2*g(n) for all n &gt;= n0}</p>
<h2 id="Big-O-Notation"><a href="#Big-O-Notation" class="headerlink" title="Big O Notation"></a>Big O Notation</h2><p>The Big O notation defines an upper bound of an algorithm, it bounds a function only from above.<br>O(g(n)) = { f(n): there exist positive constants c and  n0 such that 0 &lt;= f(n) &lt;= c*g(n) for all n &gt;= n0}</p>
<h2 id="Ω-Notation"><a href="#Ω-Notation" class="headerlink" title="Ω Notation"></a>Ω Notation</h2><p>Ω notation provides an asymptotic lower bound.<br>Ω (g(n)) = {f(n): there exist positive constants c and n0 such that 0 &lt;= c*g(n) &lt;= f(n) for all n &gt;= n0}.</p>
<h2 id="Little-ο-asymptotic-notation"><a href="#Little-ο-asymptotic-notation" class="headerlink" title="Little ο asymptotic notation"></a>Little ο asymptotic notation</h2><p>Big-Ο is used as a tight upper-bound on the growth of an algorithm’s effort.  “Little-ο” (ο()) notation is used to describe the loose upper-bound.</p>
<p><strong>Definition</strong>  : Let f(n) and g(n) be functions that map positive integers to positive real numbers. We say that f(n) is ο(g(n)) (or f(n) Ε ο(g(n))) if for any real constant c &gt; 0, there exists an integer constant n0 ≥ 1 such that 0 ≤ f(n) &lt; c*g(n).</p>
<h2 id="Little-ω-asymptotic-notation"><a href="#Little-ω-asymptotic-notation" class="headerlink" title="Little ω asymptotic notation"></a>Little ω asymptotic notation</h2><p><strong>Definition</strong> : Let f(n) and g(n) be functions that map positive integers to positive real numbers. We say that f(n) is ω(g(n)) (or f(n) ∈ ω(g(n))) if for any real constant c &gt; 0, there exists an integer constant n0 ≥ 1 such that f(n) &gt; c * g(n) ≥ 0 for every integer n ≥ n0.</p>
<h1 id="Lower-bound-theory"><a href="#Lower-bound-theory" class="headerlink" title="Lower bound theory"></a>Lower bound theory</h1><p>According to the lower bound theory, for a lower bound L(n) of an algorithm, it is not possible to have any other algorithm (for a common problem) whose time complexity is less than L(n) for random input. Also every algorithm must take at least L(n) time in worst case. Note that L(n) here is the minimum of all the possible algorithm, of maximum complexity.</p>
<p>The Lower Bound is a very important for any algorithm. Once we calculated it, then we can compare it with the actual complexity of the algorithm and if their order are same then we can declare our algorithm as optimal. </p>
<p>our main motive is to get an optimal algorithm, which is the one having its Upper Bound Same as its Lower Bound (U(n)=L(n)). Merge Sort is a common example of an optimal algorithm.</p>
<p><strong>There is a lower bound for a common problem, if the time complexity or the upper bound of one algorithm is equal to this lower bound, then this algorithm is optimal.</strong></p>
<h1 id="Analysis-of-Loop"><a href="#Analysis-of-Loop" class="headerlink" title="Analysis of Loop"></a>Analysis of Loop</h1><h2 id="O-Logn"><a href="#O-Logn" class="headerlink" title="O(Logn)"></a>O(Logn)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i *= c) &#123;</span><br><span class="line">       <span class="comment">// some O(1) expressions</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i /= c) &#123;</span><br><span class="line">       <span class="comment">// some O(1) expressions</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="O-LogLogn"><a href="#O-LogLogn" class="headerlink" title="O(LogLogn)"></a>O(LogLogn)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Here c is a constant greater than 1   </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n; i = pow(i, c)) &#123; </span><br><span class="line">      <span class="comment">// some O(1) expressions</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Here fun is sqrt or cuberoot or any other constant root</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i = fun(i)) &#123; </span><br><span class="line">      <span class="comment">// some O(1) expressions</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Analysis-of-Recurences"><a href="#Analysis-of-Recurences" class="headerlink" title="Analysis of Recurences"></a>Analysis of Recurences</h1><p>There are three methods to calculate the time complexity of recurences.</p>
<p><strong>1) Substitution Method:</strong> We make a guess for the solution and then we use mathematical induction to prove the guess is correct or incorrect.</p>
<p>For example consider the recurrence T(n) = 2T(n/2) + n</p>
<p>We guess the solution as T(n) = O(nLogn). Now we use induction<br>to prove our guess.</p>
<p>We need to prove that T(n) &lt;= cnLogn. We can assume that it is true<br>for values smaller than n.</p>
<p>T(n) = 2T(n/2) + n<br>    &lt;= cn/2Log(n/2) + n<br>    =  cnLogn - cnLog2 + n<br>    =  cnLogn - cn + n<br>    &lt;= cnLogn</p>
<p><strong>2) Recurrence Tree Method:</strong> In this method, we draw a recurrence tree and calculate the time taken by every level of tree. Finally, we sum the work done at all levels. To draw the recurrence tree, we start from the given recurrence and keep drawing till we find a pattern among levels. The pattern is typically a arithmetic or geometric series.</p>
<p>For example consider the recurrence relation<br>T(n) = T(n/4) + T(n/2) + cn2</p>
<pre><code>       cn2
     /      \
 T(n/4)     T(n/2)</code></pre>
<p>If we further break down the expression T(n/4) and T(n/2),<br>we get following recursion tree.</p>
<pre><code>            cn2
       /           \      
   c(n2)/16      c(n2)/4
  /      \          /     \</code></pre>
<p>  T(n/16)     T(n/8)  T(n/8)    T(n/4)<br>Breaking down further gives us following<br>                 cn2<br>            /            \<br>       c(n2)/16          c(n2)/4<br>       /      \            /      <br>c(n2)/256   c(n2)/64  c(n2)/64    c(n2)/16<br> /    \      /    \    /    \       /    \  </p>
<p>To know the value of T(n), we need to calculate sum of tree<br>nodes level by level. If we sum the above tree level by level,<br>we get the following series<br>T(n)  = c(n^2 + 5(n^2)/16 + 25(n^2)/256) + ….<br>The above series is geometrical progression with ratio 5/16.</p>
<p>To get an upper bound, we can sum the infinite series.<br>We get the sum as (n2)/(1 - 5/16) which is O(n2)<br><strong>3) Master Method:</strong><br>Master Method is a direct way to get the solution. The master method works only for following type of recurrences or for recurrences that can be transformed to following type.</p>
<p>T(n) = aT(n/b) + f(n) where a &gt;= 1 and b &gt; 1<br>There are following three cases:</p>
<ol>
<li><p>If f(n) = Θ(nc) where c &lt; Logba then T(n) = Θ(nLogba)</p>
</li>
<li><p>If f(n) = Θ(nc) where c = Logba then T(n) = Θ(ncLog n)</p>
</li>
</ol>
<p>3.If f(n) = Θ(nc) where c &gt; Logba then T(n) = Θ(f(n))</p>
<p>How does this work?<br>Master method is mainly derived from recurrence tree method. If we draw recurrence tree of T(n) = aT(n/b) + f(n), we can see that the work done at root is f(n) and work done at all leaves is Θ(nc) where c is Logba. And the height of recurrence tree is Logbn<br>Master Theorem<br>In recurrence tree method, we calculate total work done. If the work done at leaves is polynomially more, then leaves are the dominant part, and our result becomes the work done at leaves (Case 1). If work done at leaves and root is asymptotically same, then our result becomes height multiplied by work done at any level (Case 2). If work done at root is asymptotically more, then our result becomes work done at root (Case 3).</p>
<p>Examples of some standard algorithms whose time complexity can be evaluated using Master Method<br>Merge Sort: T(n) = 2T(n/2) + Θ(n). It falls in case 2 as c is 1 and Logba] is also 1. So the solution is Θ(n Logn)</p>
<p>Binary Search: T(n) = T(n/2) + Θ(1). It also falls in case 2 as c is 0 and Logba is also 0. So the solution is Θ(Logn)</p>
<h1 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h1><p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/">https://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Shuchen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/05/12/Analysis-of-algorithms/">http://yoursite.com/2019/05/12/Analysis-of-algorithms/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/algorithm/">algorithm</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/05/13/Search-algorithms/"><i class="fa fa-chevron-left">  </i><span>Search Algorithms</span></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://user-images.githubusercontent.com/17078557/90973809-0dd27300-e558-11ea-83d2-4431d8c12060.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Shuchen</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>